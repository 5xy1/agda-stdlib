<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--without-K</a> <a id="296" class="Pragma">--safe</a> <a id="303" class="Symbol">#-}</a>

<a id="308" class="Keyword">module</a> <a id="315" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="333" class="Keyword">where</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Algebra.html" class="Module">Algebra</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="388" class="Symbol">as</a> <a id="391" class="Module">Fin</a>   <a id="397" class="Keyword">using</a> <a id="403" class="Symbol">(</a><a id="404" href="Data.Fin.Base.html#1214" class="Datatype">Fin</a><a id="407" class="Symbol">)</a>
<a id="409" class="Keyword">open</a> <a id="414" class="Keyword">import</a> <a id="421" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="437" class="Symbol">as</a> <a id="440" class="Module">Vec</a>   <a id="446" class="Keyword">using</a> <a id="452" class="Symbol">(</a><a id="453" href="Data.Vec.Base.html#998" class="Datatype">Vec</a><a id="456" class="Symbol">;</a> <a id="458" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">_∷_</a><a id="461" class="Symbol">;</a> <a id="463" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="465" class="Symbol">)</a>
<a id="467" class="Keyword">open</a> <a id="472" class="Keyword">import</a> <a id="479" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="495" class="Symbol">as</a> <a id="498" class="Module">List</a>  <a id="504" class="Keyword">using</a> <a id="510" class="Symbol">(</a><a id="511" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="515" class="Symbol">;</a> <a id="517" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="520" class="Symbol">;</a> <a id="522" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="524" class="Symbol">)</a>
<a id="526" class="Keyword">open</a> <a id="531" class="Keyword">import</a> <a id="538" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="554" class="Symbol">as</a> <a id="557" class="Module">Maybe</a> <a id="563" class="Keyword">using</a> <a id="569" class="Symbol">(</a><a id="570" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="575" class="Symbol">;</a> <a id="577" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="581" class="Symbol">;</a> <a id="583" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="590" class="Symbol">;</a> <a id="592" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a><a id="601" class="Symbol">)</a>
<a id="603" class="Keyword">open</a> <a id="608" class="Keyword">import</a> <a id="615" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>            <a id="640" class="Keyword">using</a> <a id="646" class="Symbol">(</a><a id="647" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="648" class="Symbol">;</a> <a id="650" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="653" class="Symbol">;</a> <a id="655" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="659" class="Symbol">;</a> <a id="661" href="Data.Nat.Base.html#1235" class="Primitive Operator">_&lt;ᵇ_</a><a id="665" class="Symbol">)</a>
<a id="667" class="Keyword">open</a> <a id="672" class="Keyword">import</a> <a id="679" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>           <a id="704" class="Keyword">using</a> <a id="710" class="Symbol">(</a><a id="711" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="715" class="Symbol">;</a> <a id="717" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="730" class="Symbol">;</a> <a id="732" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="736" class="Symbol">;</a> <a id="738" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="743" class="Symbol">)</a>
<a id="745" class="Keyword">open</a> <a id="750" class="Keyword">import</a> <a id="757" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>           <a id="782" class="Keyword">using</a> <a id="788" class="Symbol">(</a><a id="789" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="790" class="Symbol">)</a>
<a id="792" class="Keyword">open</a> <a id="797" class="Keyword">import</a> <a id="804" href="Data.String.html" class="Module">Data.String</a> <a id="816" class="Symbol">as</a> <a id="819" class="Module">String</a>    <a id="829" class="Keyword">using</a> <a id="835" class="Symbol">(</a><a id="836" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="842" class="Symbol">;</a> <a id="844" href="Data.String.Base.html#2366" class="Function Operator">_++_</a><a id="848" class="Symbol">;</a> <a id="850" href="Data.String.Base.html#2826" class="Function">parens</a><a id="856" class="Symbol">)</a>
<a id="858" class="Keyword">open</a> <a id="863" class="Keyword">import</a> <a id="870" href="Data.Product.html" class="Module">Data.Product</a>             <a id="895" class="Keyword">using</a> <a id="901" class="Symbol">(</a><a id="902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="905" class="Symbol">;</a> <a id="907" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="912" class="Symbol">)</a>
<a id="914" class="Keyword">open</a> <a id="919" class="Keyword">import</a> <a id="926" href="Function.html" class="Module">Function</a>
<a id="935" class="Keyword">open</a> <a id="940" class="Keyword">import</a> <a id="947" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="975" class="Keyword">open</a> <a id="980" class="Keyword">import</a> <a id="987" href="Reflection.html" class="Module">Reflection</a>
<a id="998" class="Keyword">open</a> <a id="1003" class="Keyword">import</a> <a id="1010" href="Reflection.Argument.html" class="Module">Reflection.Argument</a>
<a id="1030" class="Keyword">open</a> <a id="1035" class="Keyword">import</a> <a id="1042" href="Reflection.Term.html" class="Module">Reflection.Term</a> <a id="1058" class="Symbol">as</a> <a id="1061" class="Module">Term</a>
<a id="1066" class="Keyword">open</a> <a id="1071" class="Keyword">import</a> <a id="1078" href="Reflection.Name.html" class="Module">Reflection.Name</a> <a id="1094" class="Symbol">as</a> <a id="1097" class="Module">Name</a>
<a id="1102" class="Keyword">open</a> <a id="1107" class="Keyword">import</a> <a id="1114" href="Reflection.TypeChecking.Monad.Syntax.html" class="Module">Reflection.TypeChecking.Monad.Syntax</a>
<a id="1151" class="Keyword">open</a> <a id="1156" class="Keyword">import</a> <a id="1163" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1183" class="Keyword">open</a> <a id="1188" class="Keyword">import</a> <a id="1195" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1216" class="Keyword">import</a> <a id="1223" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1243" class="Symbol">as</a> <a id="1246" class="Module">Vec</a>

<a id="1251" class="Keyword">open</a> <a id="1256" class="Keyword">import</a> <a id="1263" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1295" class="Keyword">renaming</a> <a id="1304" class="Symbol">(</a><a id="1305" href="Tactic.RingSolver.NonReflective.html#2953" class="Function">solve</a> <a id="1311" class="Symbol">to</a> <a id="1314" class="Function">solver</a><a id="1320" class="Symbol">)</a>
<a id="1322" class="Keyword">open</a> <a id="1327" class="Keyword">import</a> <a id="1334" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1379" class="Keyword">open</a> <a id="1384" class="Keyword">import</a> <a id="1391" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1421" class="Symbol">as</a> <a id="1424" class="Module">NatSet</a>

<a id="1432" class="Keyword">open</a> <a id="1437" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Module">AlmostCommutativeRing</a>

<a id="1460" class="Comment">------------------------------------------------------------------------</a>
<a id="1533" class="Comment">-- Utilities</a>

<a id="1547" class="Keyword">private</a>
  <a id="1557" class="Keyword">infix</a> <a id="1563" class="Number">4</a> <a id="1565" href="Tactic.RingSolver.html#1572" class="Function Operator">_⇓≟_</a>
  <a id="_⇓≟_"></a><a id="1572" href="Tactic.RingSolver.html#1572" class="Function Operator">_⇓≟_</a> <a id="1577" class="Symbol">:</a> <a id="1579" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1585" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="1590" class="Symbol">→</a> <a id="1592" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="1597" class="Symbol">→</a> <a id="1599" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="1606" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="1614" href="Tactic.RingSolver.html#1572" class="Function Operator">⇓≟</a> <a id="1617" class="Symbol">_</a> <a id="1619" class="Symbol">=</a> <a id="1621" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="1629" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1634" href="Tactic.RingSolver.html#1634" class="Bound">x</a>  <a id="1637" href="Tactic.RingSolver.html#1572" class="Function Operator">⇓≟</a> <a id="1640" href="Tactic.RingSolver.html#1640" class="Bound">y</a> <a id="1642" class="Symbol">=</a> <a id="1644" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊</a> <a id="1646" href="Tactic.RingSolver.html#1634" class="Bound">x</a> <a id="1648" href="Reflection.Name.html#1403" class="Function Operator">Name.≟</a> <a id="1655" href="Tactic.RingSolver.html#1640" class="Bound">y</a> <a id="1657" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌋</a>
  <a id="1661" class="Symbol">{-#</a> <a id="1665" class="Keyword">INLINE</a> <a id="1672" href="Tactic.RingSolver.html#1572" class="Function Operator">_⇓≟_</a> <a id="1677" class="Symbol">#-}</a>

  <a id="VarMap"></a><a id="1684" href="Tactic.RingSolver.html#1684" class="Function">VarMap</a> <a id="1691" class="Symbol">:</a> <a id="1693" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="1699" href="Tactic.RingSolver.html#1684" class="Function">VarMap</a> <a id="1706" class="Symbol">=</a> <a id="1708" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1710" class="Symbol">→</a> <a id="1712" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1718" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1726" href="Tactic.RingSolver.html#1726" class="Function">getVisible</a> <a id="1737" class="Symbol">:</a> <a id="1739" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="1743" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1748" class="Symbol">→</a> <a id="1750" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1756" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="1763" href="Tactic.RingSolver.html#1726" class="Function">getVisible</a> <a id="1774" class="Symbol">(</a><a id="1775" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="1779" class="Symbol">(</a><a id="1780" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="1789" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="1797" class="Symbol">_)</a> <a id="1800" href="Tactic.RingSolver.html#1800" class="Bound">x</a><a id="1801" class="Symbol">)</a> <a id="1803" class="Symbol">=</a> <a id="1805" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1810" href="Tactic.RingSolver.html#1800" class="Bound">x</a>
  <a id="1814" href="Tactic.RingSolver.html#1726" class="CatchallClause Function">getVisible</a><a id="1824" class="CatchallClause"> </a><a id="1825" class="CatchallClause Symbol">_</a>                            <a id="1854" class="Symbol">=</a> <a id="1856" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1867" href="Tactic.RingSolver.html#1867" class="Function">getVisibleArgs</a> <a id="1882" class="Symbol">:</a> <a id="1884" class="Symbol">∀</a> <a id="1886" href="Tactic.RingSolver.html#1886" class="Bound">n</a> <a id="1888" class="Symbol">→</a> <a id="1890" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1895" class="Symbol">→</a> <a id="1897" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1903" class="Symbol">(</a><a id="1904" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="1908" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1913" href="Tactic.RingSolver.html#1886" class="Bound">n</a><a id="1914" class="Symbol">)</a>
  <a id="1918" href="Tactic.RingSolver.html#1867" class="Function">getVisibleArgs</a> <a id="1933" href="Tactic.RingSolver.html#1933" class="Bound">n</a> <a id="1935" class="Symbol">(</a><a id="1936" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="1940" class="Symbol">_</a> <a id="1942" href="Tactic.RingSolver.html#1942" class="Bound">xs</a><a id="1944" class="Symbol">)</a> <a id="1946" class="Symbol">=</a> <a id="1948" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="1958" href="Data.Vec.Base.html#8083" class="Function">Vec.reverse</a> <a id="1970" class="Symbol">(</a><a id="1971" href="Data.List.Base.html#4293" class="Function">List.foldl</a> <a id="1982" href="Tactic.RingSolver.html#2033" class="Function">f</a> <a id="1984" href="Tactic.RingSolver.html#2177" class="Function">c</a> <a id="1986" class="Symbol">(</a><a id="1987" href="Data.List.Base.html#1629" class="Function">List.mapMaybe</a> <a id="2001" href="Tactic.RingSolver.html#1726" class="Function">getVisible</a> <a id="2012" href="Tactic.RingSolver.html#1942" class="Bound">xs</a><a id="2014" class="Symbol">)</a> <a id="2016" href="Tactic.RingSolver.html#1933" class="Bound">n</a><a id="2017" class="Symbol">)</a>
    <a id="2023" class="Keyword">where</a>
    <a id="2033" href="Tactic.RingSolver.html#2033" class="Function">f</a> <a id="2035" class="Symbol">:</a> <a id="2037" class="Symbol">(∀</a> <a id="2040" href="Tactic.RingSolver.html#2040" class="Bound">n</a> <a id="2042" class="Symbol">→</a> <a id="2044" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2050" class="Symbol">(</a><a id="2051" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="2055" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2060" href="Tactic.RingSolver.html#2040" class="Bound">n</a><a id="2061" class="Symbol">))</a> <a id="2064" class="Symbol">→</a> <a id="2066" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2071" class="Symbol">→</a> <a id="2073" class="Symbol">∀</a> <a id="2075" href="Tactic.RingSolver.html#2075" class="Bound">n</a> <a id="2077" class="Symbol">→</a> <a id="2079" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2085" class="Symbol">(</a><a id="2086" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="2090" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2095" href="Tactic.RingSolver.html#2075" class="Bound">n</a><a id="2096" class="Symbol">)</a>
    <a id="2102" href="Tactic.RingSolver.html#2033" class="Function">f</a> <a id="2104" href="Tactic.RingSolver.html#2104" class="Bound">xs</a> <a id="2107" href="Tactic.RingSolver.html#2107" class="Bound">x</a> <a id="2109" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2117" class="Symbol">=</a> <a id="2119" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2124" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
    <a id="2131" href="Tactic.RingSolver.html#2033" class="Function">f</a> <a id="2133" href="Tactic.RingSolver.html#2133" class="Bound">xs</a> <a id="2136" href="Tactic.RingSolver.html#2136" class="Bound">x</a> <a id="2138" class="Symbol">(</a><a id="2139" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2143" href="Tactic.RingSolver.html#2143" class="Bound">n</a><a id="2144" class="Symbol">)</a> <a id="2146" class="Symbol">=</a> <a id="2148" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="2158" class="Symbol">(</a><a id="2159" href="Tactic.RingSolver.html#2136" class="Bound">x</a> <a id="2161" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷_</a><a id="2163" class="Symbol">)</a> <a id="2165" class="Symbol">(</a><a id="2166" href="Tactic.RingSolver.html#2133" class="Bound">xs</a> <a id="2169" href="Tactic.RingSolver.html#2143" class="Bound">n</a><a id="2170" class="Symbol">)</a>

    <a id="2177" href="Tactic.RingSolver.html#2177" class="Function">c</a> <a id="2179" class="Symbol">:</a> <a id="2181" class="Symbol">∀</a> <a id="2183" href="Tactic.RingSolver.html#2183" class="Bound">n</a> <a id="2185" class="Symbol">→</a> <a id="2187" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2193" class="Symbol">(</a><a id="2194" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="2198" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2203" href="Tactic.RingSolver.html#2183" class="Bound">n</a><a id="2204" class="Symbol">)</a>
    <a id="2210" href="Tactic.RingSolver.html#2177" class="Function">c</a> <a id="2212" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="2221" class="Symbol">=</a> <a id="2223" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2228" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
    <a id="2235" href="Tactic.RingSolver.html#2177" class="Function">c</a> <a id="2237" class="Symbol">(</a><a id="2238" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2242" class="Symbol">_</a> <a id="2244" class="Symbol">)</a> <a id="2246" class="Symbol">=</a> <a id="2248" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
  <a id="2258" href="Tactic.RingSolver.html#1867" class="CatchallClause Function">getVisibleArgs</a><a id="2272" class="CatchallClause"> </a><a id="2273" class="CatchallClause Symbol">_</a><a id="2274" class="CatchallClause"> </a><a id="2275" class="CatchallClause Symbol">_</a> <a id="2277" class="Symbol">=</a> <a id="2279" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2290" href="Tactic.RingSolver.html#2290" class="Function">curriedTerm</a> <a id="2302" class="Symbol">:</a> <a id="2304" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="2311" class="Symbol">→</a> <a id="2313" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="2320" href="Tactic.RingSolver.html#2290" class="Function">curriedTerm</a> <a id="2332" class="Symbol">=</a> <a id="2334" href="Data.List.Base.html#4192" class="Function">List.foldr</a> <a id="2345" href="Tactic.RingSolver.html#2386" class="Function">go</a> <a id="2348" href="Data.Vec.Reflection.html#662" class="Function">Vec.`[]</a> <a id="2356" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2358" href="Tactic.RingSolver.Core.NatSet.html#3284" class="Function">NatSet.toList</a>
    <a id="2376" class="Keyword">where</a>
    <a id="2386" href="Tactic.RingSolver.html#2386" class="Function">go</a> <a id="2389" class="Symbol">:</a> <a id="2391" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2393" class="Symbol">→</a> <a id="2395" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2400" class="Symbol">→</a> <a id="2402" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
    <a id="2411" href="Tactic.RingSolver.html#2386" class="Function">go</a> <a id="2414" href="Tactic.RingSolver.html#2414" class="Bound">x</a> <a id="2416" href="Tactic.RingSolver.html#2416" class="Bound">xs</a> <a id="2419" class="Symbol">=</a> <a id="2421" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="2425" href="Tactic.RingSolver.html#2414" class="Bound">x</a> <a id="2427" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2430" href="Data.Vec.Reflection.html#712" class="Function Operator">Vec.`∷</a> <a id="2437" href="Tactic.RingSolver.html#2416" class="Bound">xs</a>

<a id="2441" class="Comment">------------------------------------------------------------------------</a>
<a id="2514" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2549" href="Tactic.RingSolver.html#2549" class="Function">`AlmostCommutativeRing</a> <a id="2572" class="Symbol">:</a> <a id="2574" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2579" href="Tactic.RingSolver.html#2549" class="Function">`AlmostCommutativeRing</a> <a id="2602" class="Symbol">=</a> <a id="2604" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="2608" class="Symbol">(</a><a id="2609" class="Keyword">quote</a> <a id="2615" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Record">AlmostCommutativeRing</a><a id="2636" class="Symbol">)</a> <a id="2638" class="Symbol">(</a><a id="2639" class="Number">2</a> <a id="2641" href="Reflection.Term.html#2487" class="Function Operator">⋯⟨∷⟩</a> <a id="2646" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2648" class="Symbol">)</a>

<a id="2651" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2658" href="Tactic.RingSolver.html#2658" class="Record">RingOperatorTerms</a> <a id="2676" class="Symbol">:</a> <a id="2678" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2682" class="Keyword">where</a>
  <a id="2690" class="Keyword">constructor</a> <a id="+⇒_*⇒_^⇒_-⇒_"></a><a id="2702" href="Tactic.RingSolver.html#2702" class="InductiveConstructor Operator">+⇒_*⇒_^⇒_-⇒_</a>
  <a id="2717" class="Keyword">field</a>
    <a id="RingOperatorTerms.+′"></a><a id="2727" href="Tactic.RingSolver.html#2727" class="Field">+′</a> <a id="RingOperatorTerms.*′"></a><a id="2730" href="Tactic.RingSolver.html#2730" class="Field">*′</a> <a id="RingOperatorTerms.^′"></a><a id="2733" href="Tactic.RingSolver.html#2733" class="Field">^′</a> <a id="RingOperatorTerms.-′"></a><a id="2736" href="Tactic.RingSolver.html#2736" class="Field">-′</a> <a id="2739" class="Symbol">:</a> <a id="2741" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2747" href="Tactic.RingSolver.html#2747" class="Function">checkIsRing</a> <a id="2759" class="Symbol">:</a> <a id="2761" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2766" class="Symbol">→</a> <a id="2768" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="2771" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2776" href="Tactic.RingSolver.html#2747" class="Function">checkIsRing</a> <a id="2788" href="Tactic.RingSolver.html#2788" class="Bound">ring</a> <a id="2793" class="Symbol">=</a> <a id="2795" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="2805" href="Tactic.RingSolver.html#2788" class="Bound">ring</a> <a id="2810" href="Tactic.RingSolver.html#2549" class="Function">`AlmostCommutativeRing</a>

<a id="2834" class="Keyword">module</a> <a id="RingReflection"></a><a id="2841" href="Tactic.RingSolver.html#2841" class="Module">RingReflection</a> <a id="2856" class="Symbol">(</a><a id="2857" href="Tactic.RingSolver.html#2857" class="Bound">`ring</a> <a id="2863" class="Symbol">:</a> <a id="2865" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="2869" class="Symbol">)</a> <a id="2871" class="Keyword">where</a>

  <a id="2880" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2948" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="3015" class="Comment">-- the required ring arguments</a>
  <a id="3048" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3096" class="Keyword">infixr</a> <a id="3103" class="Number">6</a> <a id="3105" href="Tactic.RingSolver.html#3112" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3112" href="Tactic.RingSolver.html#3112" class="Function Operator">_$ʳ_</a> <a id="3117" class="Symbol">:</a> <a id="3119" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3124" class="Symbol">→</a> <a id="3126" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="3131" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3136" class="Symbol">→</a> <a id="3138" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3145" href="Tactic.RingSolver.html#3145" class="Bound">nm</a> <a id="3148" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3151" href="Tactic.RingSolver.html#3151" class="Bound">args</a> <a id="3156" class="Symbol">=</a> <a id="3158" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3162" href="Tactic.RingSolver.html#3145" class="Bound">nm</a> <a id="3165" class="Symbol">(</a><a id="3166" class="Number">2</a> <a id="3168" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3173" href="Tactic.RingSolver.html#2857" class="Bound">`ring</a> <a id="3179" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3183" href="Tactic.RingSolver.html#3151" class="Bound">args</a><a id="3187" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3192" href="Tactic.RingSolver.html#3192" class="Function">`Carrier</a> <a id="3201" class="Symbol">:</a> <a id="3203" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3210" href="Tactic.RingSolver.html#3192" class="Function">`Carrier</a> <a id="3219" class="Symbol">=</a> <a id="3221" class="Keyword">quote</a> <a id="3227" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1387" class="Field">Carrier</a> <a id="3235" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3238" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3244" href="Tactic.RingSolver.html#3244" class="Function">`refl</a> <a id="3250" class="Symbol">:</a> <a id="3252" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3259" href="Tactic.RingSolver.html#3244" class="Function">`refl</a> <a id="3265" class="Symbol">=</a> <a id="3267" class="Keyword">quote</a> <a id="3273" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function">refl</a> <a id="3278" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3281" class="Symbol">(</a><a id="3282" class="Number">1</a> <a id="3284" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3289" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3291" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3296" href="Tactic.RingSolver.html#3296" class="Function">`sym</a> <a id="3301" class="Symbol">:</a> <a id="3303" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3308" class="Symbol">→</a> <a id="3310" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3317" href="Tactic.RingSolver.html#3296" class="Function">`sym</a> <a id="3322" href="Tactic.RingSolver.html#3322" class="Bound">x≈y</a> <a id="3326" class="Symbol">=</a> <a id="3328" class="Keyword">quote</a> <a id="3334" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="3338" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3341" class="Symbol">(</a><a id="3342" class="Number">2</a> <a id="3344" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3349" href="Tactic.RingSolver.html#3322" class="Bound">x≈y</a> <a id="3353" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3357" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3359" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3364" href="Tactic.RingSolver.html#3364" class="Function">`trans</a> <a id="3371" class="Symbol">:</a> <a id="3373" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3378" class="Symbol">→</a> <a id="3380" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3385" class="Symbol">→</a> <a id="3387" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3394" href="Tactic.RingSolver.html#3364" class="Function">`trans</a> <a id="3401" href="Tactic.RingSolver.html#3401" class="Bound">x≈y</a> <a id="3405" href="Tactic.RingSolver.html#3405" class="Bound">y≈z</a> <a id="3409" class="Symbol">=</a> <a id="3411" class="Keyword">quote</a> <a id="3417" href="Relation.Binary.Structures.html#1620" class="Function">trans</a> <a id="3423" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3426" class="Symbol">(</a><a id="3427" class="Number">3</a> <a id="3429" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3434" href="Tactic.RingSolver.html#3401" class="Bound">x≈y</a> <a id="3438" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3442" href="Tactic.RingSolver.html#3405" class="Bound">y≈z</a> <a id="3446" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3450" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3452" class="Symbol">)</a>

  <a id="3457" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3523" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3590" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3648" href="Tactic.RingSolver.html#3648" class="Function">getRingOperatorTerms</a> <a id="3669" class="Symbol">:</a> <a id="3671" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3676" class="Symbol">→</a> <a id="3678" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="3681" href="Tactic.RingSolver.html#2658" class="Record">RingOperatorTerms</a>
  <a id="3701" href="Tactic.RingSolver.html#3648" class="Function">getRingOperatorTerms</a> <a id="3722" href="Tactic.RingSolver.html#3722" class="Bound">ring</a> <a id="3727" class="Symbol">=</a> <a id="3729" class="Symbol">⦇</a>
    <a id="3735" href="Tactic.RingSolver.html#2702" class="InductiveConstructor Operator">+⇒</a> <a id="3738" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3748" class="Symbol">(</a><a id="3749" class="Keyword">quote</a> <a id="3755" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a> <a id="3759" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3762" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3764" class="Symbol">)</a>
    <a id="3770" href="Tactic.RingSolver.html#2702" class="InductiveConstructor Operator">*⇒</a> <a id="3773" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3783" class="Symbol">(</a><a id="3784" class="Keyword">quote</a> <a id="3790" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a> <a id="3794" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3797" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3799" class="Symbol">)</a>
    <a id="3805" href="Tactic.RingSolver.html#2702" class="InductiveConstructor Operator">^⇒</a> <a id="3808" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3818" class="Symbol">(</a><a id="3819" class="Keyword">quote</a> <a id="3825" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a> <a id="3829" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3832" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3834" class="Symbol">)</a>
    <a id="3840" href="Tactic.RingSolver.html#2702" class="InductiveConstructor Operator">-⇒</a> <a id="3843" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3853" class="Symbol">(</a><a id="3854" class="Keyword">quote</a>  <a id="3861" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a> <a id="3864" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="3867" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3869" class="Symbol">)</a>
    <a id="3875" class="Symbol">⦈</a>

<a id="3878" class="Comment">------------------------------------------------------------------------</a>
<a id="3951" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3992" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="3999" href="Tactic.RingSolver.html#3999" class="Module">RingSolverReflection</a> <a id="4020" class="Symbol">(</a><a id="4021" href="Tactic.RingSolver.html#4021" class="Bound">ring</a> <a id="4026" class="Symbol">:</a> <a id="4028" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4032" class="Symbol">)</a> <a id="4034" class="Symbol">(</a><a id="4035" href="Tactic.RingSolver.html#4035" class="Bound">numberOfVariables</a> <a id="4053" class="Symbol">:</a> <a id="4055" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4056" class="Symbol">)</a> <a id="4058" class="Keyword">where</a>
  <a id="4066" class="Keyword">open</a> <a id="4071" href="Tactic.RingSolver.html#2841" class="Module">RingReflection</a> <a id="4086" href="Tactic.RingSolver.html#4021" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4094" href="Tactic.RingSolver.html#4094" class="Function">`numberOfVariables</a> <a id="4113" class="Symbol">:</a> <a id="4115" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4122" href="Tactic.RingSolver.html#4094" class="Function">`numberOfVariables</a> <a id="4141" class="Symbol">=</a> <a id="4143" href="Data.Nat.Reflection.html#636" class="Function">toTerm</a> <a id="4150" href="Tactic.RingSolver.html#4035" class="Bound">numberOfVariables</a>

  <a id="4171" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4241" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4314" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4383" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4452" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4516" class="Keyword">infix</a> <a id="4522" class="Number">-1</a> <a id="4525" href="Tactic.RingSolver.html#4532" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4532" href="Tactic.RingSolver.html#4532" class="Function Operator">_$ᵉ_</a> <a id="4537" class="Symbol">:</a> <a id="4539" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4544" class="Symbol">→</a> <a id="4546" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4551" class="Symbol">(</a><a id="4552" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="4556" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4560" class="Symbol">)</a> <a id="4562" class="Symbol">→</a> <a id="4564" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4571" href="Tactic.RingSolver.html#4571" class="Bound">e</a> <a id="4573" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="4576" href="Tactic.RingSolver.html#4576" class="Bound">xs</a> <a id="4579" class="Symbol">=</a> <a id="4581" href="Agda.Builtin.Reflection.html#4846" class="InductiveConstructor">con</a> <a id="4585" href="Tactic.RingSolver.html#4571" class="Bound">e</a> <a id="4587" class="Symbol">(</a><a id="4588" class="Number">1</a> <a id="4590" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="4595" href="Tactic.RingSolver.html#3192" class="Function">`Carrier</a> <a id="4604" href="Reflection.Argument.html#1727" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4608" href="Tactic.RingSolver.html#4094" class="Function">`numberOfVariables</a> <a id="4627" href="Reflection.Argument.html#1727" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4631" href="Tactic.RingSolver.html#4576" class="Bound">xs</a><a id="4633" class="Symbol">)</a>

  <a id="4638" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4666" href="Tactic.RingSolver.html#4666" class="Function">`Κ</a> <a id="4669" class="Symbol">:</a> <a id="4671" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4676" class="Symbol">→</a> <a id="4678" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4685" href="Tactic.RingSolver.html#4666" class="Function">`Κ</a> <a id="4688" href="Tactic.RingSolver.html#4688" class="Bound">x</a> <a id="4690" class="Symbol">=</a> <a id="4692" class="Keyword">quote</a> <a id="4698" href="Tactic.RingSolver.Core.Expression.html#538" class="InductiveConstructor">Κ</a> <a id="4700" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="4703" class="Symbol">(</a><a id="4704" href="Tactic.RingSolver.html#4688" class="Bound">x</a> <a id="4706" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4710" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4712" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4717" href="Tactic.RingSolver.html#4717" class="Function">`I</a> <a id="4720" class="Symbol">:</a> <a id="4722" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4727" class="Symbol">→</a> <a id="4729" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4736" href="Tactic.RingSolver.html#4717" class="Function">`I</a> <a id="4739" href="Tactic.RingSolver.html#4739" class="Bound">x</a> <a id="4741" class="Symbol">=</a> <a id="4743" class="Keyword">quote</a> <a id="4749" href="Tactic.RingSolver.Core.Expression.html#589" class="InductiveConstructor">Ι</a> <a id="4751" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="4754" class="Symbol">(</a><a id="4755" href="Tactic.RingSolver.html#4739" class="Bound">x</a> <a id="4757" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4761" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4763" class="Symbol">)</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4768" href="Tactic.RingSolver.html#4768" class="Function Operator">_`⊜_</a> <a id="4773" class="Symbol">:</a> <a id="4775" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4780" class="Symbol">→</a> <a id="4782" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4787" class="Symbol">→</a> <a id="4789" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4796" href="Tactic.RingSolver.html#4796" class="Bound">x</a> <a id="4798" href="Tactic.RingSolver.html#4768" class="Function Operator">`⊜</a> <a id="4801" href="Tactic.RingSolver.html#4801" class="Bound">y</a> <a id="4803" class="Symbol">=</a> <a id="4805" class="Keyword">quote</a> <a id="4811" href="Tactic.RingSolver.NonReflective.html#3315" class="Function Operator">_⊜_</a>  <a id="4816" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="4819" class="Symbol">(</a><a id="4820" href="Tactic.RingSolver.html#4094" class="Function">`numberOfVariables</a> <a id="4839" href="Reflection.Argument.html#1727" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4843" href="Tactic.RingSolver.html#4796" class="Bound">x</a> <a id="4845" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4849" href="Tactic.RingSolver.html#4801" class="Bound">y</a> <a id="4851" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4855" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4857" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4862" href="Tactic.RingSolver.html#4862" class="Function">`correct</a> <a id="4871" class="Symbol">:</a> <a id="4873" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4878" class="Symbol">→</a> <a id="4880" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4885" class="Symbol">→</a> <a id="4887" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4894" href="Tactic.RingSolver.html#4862" class="Function">`correct</a> <a id="4903" href="Tactic.RingSolver.html#4903" class="Bound">x</a> <a id="4905" href="Tactic.RingSolver.html#4905" class="Bound">ρ</a> <a id="4907" class="Symbol">=</a> <a id="4909" class="Keyword">quote</a> <a id="4915" href="Tactic.RingSolver.NonReflective.html#2289" class="Function">Ops.correct</a> <a id="4927" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="4930" class="Symbol">(</a><a id="4931" class="Number">1</a> <a id="4933" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="4938" href="Tactic.RingSolver.html#4903" class="Bound">x</a> <a id="4940" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4944" href="Tactic.RingSolver.html#4905" class="Bound">ρ</a> <a id="4946" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4950" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4952" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4957" href="Tactic.RingSolver.html#4957" class="Function">`solver</a> <a id="4965" class="Symbol">:</a> <a id="4967" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4972" class="Symbol">→</a> <a id="4974" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4979" class="Symbol">→</a> <a id="4981" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4988" href="Tactic.RingSolver.html#4957" class="Function">`solver</a> <a id="4996" href="Tactic.RingSolver.html#4996" class="Bound">`f</a> <a id="4999" href="Tactic.RingSolver.html#4999" class="Bound">`eq</a> <a id="5003" class="Symbol">=</a> <a id="5005" class="Keyword">quote</a> <a id="5011" href="Tactic.RingSolver.html#1314" class="Function">solver</a> <a id="5018" href="Tactic.RingSolver.html#3112" class="Function Operator">$ʳ</a> <a id="5021" class="Symbol">(</a><a id="5022" href="Tactic.RingSolver.html#4094" class="Function">`numberOfVariables</a> <a id="5041" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5045" href="Tactic.RingSolver.html#4996" class="Bound">`f</a> <a id="5048" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5052" href="Tactic.RingSolver.html#4999" class="Bound">`eq</a> <a id="5056" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5060" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5062" class="Symbol">)</a>

  <a id="5067" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5134" class="Comment">-- used internally by the solver.</a>
  <a id="5170" class="Comment">--</a>
  <a id="5175" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5241" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5304" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5370" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5438" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5505" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5567" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5608" class="Comment">--</a>
  <a id="5613" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5682" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5750" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5807" href="Tactic.RingSolver.html#5807" class="Function">convertTerm</a> <a id="5819" class="Symbol">:</a> <a id="5821" href="Tactic.RingSolver.html#2658" class="Record">RingOperatorTerms</a> <a id="5839" class="Symbol">→</a> <a id="5841" href="Tactic.RingSolver.html#1684" class="Function">VarMap</a> <a id="5848" class="Symbol">→</a> <a id="5850" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5855" class="Symbol">→</a> <a id="5857" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5860" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="5867" href="Tactic.RingSolver.html#5807" class="Function">convertTerm</a> <a id="5879" href="Tactic.RingSolver.html#5879" class="Bound">operatorTerms</a> <a id="5893" href="Tactic.RingSolver.html#5893" class="Bound">varMap</a> <a id="5900" class="Symbol">=</a> <a id="5902" href="Tactic.RingSolver.html#5979" class="Function">convert</a>
    <a id="5914" class="Keyword">where</a>
    <a id="5924" class="Keyword">open</a> <a id="5929" href="Tactic.RingSolver.html#2658" class="Module">RingOperatorTerms</a> <a id="5947" href="Tactic.RingSolver.html#5879" class="Bound">operatorTerms</a>

    <a id="5966" class="Keyword">mutual</a>
      <a id="5979" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="5987" class="Symbol">:</a> <a id="5989" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5994" class="Symbol">→</a> <a id="5996" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5999" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="6010" class="Comment">-- Definitions in ring&#39;s fields</a>
      <a id="6048" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6056" class="Symbol">(</a><a id="6057" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6061" class="Symbol">(</a><a id="6062" class="Keyword">quote</a> <a id="6068" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a><a id="6071" class="Symbol">)</a> <a id="6073" href="Tactic.RingSolver.html#6073" class="Bound">xs</a><a id="6075" class="Symbol">)</a> <a id="6077" class="Symbol">=</a> <a id="6079" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="6090" class="Symbol">(</a><a id="6091" class="Keyword">quote</a> <a id="6097" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="6100" class="Symbol">)</a> <a id="6102" href="Tactic.RingSolver.html#6073" class="Bound">xs</a>
      <a id="6111" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6119" class="Symbol">(</a><a id="6120" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6124" class="Symbol">(</a><a id="6125" class="Keyword">quote</a> <a id="6131" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a><a id="6134" class="Symbol">)</a> <a id="6136" href="Tactic.RingSolver.html#6136" class="Bound">xs</a><a id="6138" class="Symbol">)</a> <a id="6140" class="Symbol">=</a> <a id="6142" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="6153" class="Symbol">(</a><a id="6154" class="Keyword">quote</a> <a id="6160" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="6163" class="Symbol">)</a> <a id="6165" href="Tactic.RingSolver.html#6136" class="Bound">xs</a>
      <a id="6174" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6182" class="Symbol">(</a><a id="6183" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6187" class="Symbol">(</a><a id="6188" class="Keyword">quote</a>  <a id="6195" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="6197" class="Symbol">)</a> <a id="6199" href="Tactic.RingSolver.html#6199" class="Bound">xs</a><a id="6201" class="Symbol">)</a> <a id="6203" class="Symbol">=</a> <a id="6205" href="Tactic.RingSolver.html#7207" class="Function">convertOp₁</a> <a id="6216" class="Symbol">(</a><a id="6217" class="Keyword">quote</a>  <a id="6224" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="6226" class="Symbol">)</a> <a id="6228" href="Tactic.RingSolver.html#6199" class="Bound">xs</a>
      <a id="6237" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6245" class="Symbol">(</a><a id="6246" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6250" class="Symbol">(</a><a id="6251" class="Keyword">quote</a> <a id="6257" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a><a id="6260" class="Symbol">)</a> <a id="6262" href="Tactic.RingSolver.html#6262" class="Bound">xs</a><a id="6264" class="Symbol">)</a> <a id="6266" class="Symbol">=</a> <a id="6268" href="Tactic.RingSolver.html#7431" class="Function">convertExp</a> <a id="6279" href="Tactic.RingSolver.html#6262" class="Bound">xs</a>
      <a id="6288" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6366" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6374" class="Symbol">(</a><a id="6375" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6379" href="Tactic.RingSolver.html#6379" class="Bound">nm</a>          <a id="6391" href="Tactic.RingSolver.html#6391" class="Bound">xs</a><a id="6393" class="Symbol">)</a> <a id="6395" class="Symbol">=</a> <a id="6397" href="Tactic.RingSolver.html#7667" class="Function">convertUnknownName</a> <a id="6416" href="Tactic.RingSolver.html#6379" class="Bound">nm</a> <a id="6419" href="Tactic.RingSolver.html#6391" class="Bound">xs</a>
      <a id="6428" class="Comment">-- Variables</a>
      <a id="6447" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6455" href="Tactic.RingSolver.html#6455" class="Bound">v</a><a id="6456" class="Symbol">@(</a><a id="6458" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="6462" href="Tactic.RingSolver.html#6462" class="Bound">x</a> <a id="6464" class="Symbol">_)</a>          <a id="6476" class="Symbol">=</a> <a id="6478" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="6485" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6487" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a> <a id="6497" class="Symbol">(</a><a id="6498" href="Tactic.RingSolver.html#4666" class="Function">`Κ</a> <a id="6501" href="Tactic.RingSolver.html#6455" class="Bound">v</a><a id="6502" class="Symbol">)</a> <a id="6504" class="Symbol">(</a><a id="6505" href="Tactic.RingSolver.html#5893" class="Bound">varMap</a> <a id="6512" href="Tactic.RingSolver.html#6462" class="Bound">x</a><a id="6513" class="Symbol">)</a>
      <a id="6521" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6575" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="6583" class="Symbol">(</a><a id="6584" href="Data.Nat.Reflection.html#599" class="InductiveConstructor">`suc</a> <a id="6589" href="Tactic.RingSolver.html#6589" class="Bound">x</a><a id="6590" class="Symbol">)</a>             <a id="6604" class="Symbol">=</a> <a id="6606" href="Tactic.RingSolver.html#8131" class="Function">convertSuc</a> <a id="6617" href="Tactic.RingSolver.html#6589" class="Bound">x</a>
      <a id="6625" href="Tactic.RingSolver.html#5979" class="CatchallClause Function">convert</a><a id="6632" class="CatchallClause"> </a><a id="6633" href="Tactic.RingSolver.html#6633" class="CatchallClause Bound">t</a>                    <a id="6654" class="Symbol">=</a> <a id="6656" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="6663" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6665" href="Tactic.RingSolver.html#4666" class="Function">`Κ</a> <a id="6668" href="Tactic.RingSolver.html#6633" class="Bound">t</a>

      <a id="6677" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6746" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6816" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="6885" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="6942" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="6953" class="Symbol">:</a> <a id="6955" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="6960" class="Symbol">→</a> <a id="6962" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="6967" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="6972" class="Symbol">→</a> <a id="6974" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="6977" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="6988" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="6999" href="Tactic.RingSolver.html#6999" class="Bound">nm</a> <a id="7002" class="Symbol">(</a><a id="7003" href="Tactic.RingSolver.html#7003" class="Bound">x</a> <a id="7005" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7009" href="Tactic.RingSolver.html#7009" class="Bound">y</a> <a id="7011" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7015" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7017" class="Symbol">)</a> <a id="7019" class="Symbol">=</a> <a id="7021" class="Keyword">do</a> <a id="7024" href="Tactic.RingSolver.html#7024" class="Bound">x&#39;</a> <a id="7027" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7029" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="7037" href="Tactic.RingSolver.html#7003" class="Bound">x</a><a id="7038" class="Symbol">;</a> <a id="7040" href="Tactic.RingSolver.html#7040" class="Bound">y&#39;</a> <a id="7043" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7045" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="7053" href="Tactic.RingSolver.html#7009" class="Bound">y</a><a id="7054" class="Symbol">;</a> <a id="7056" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7063" class="Symbol">(</a><a id="7064" href="Tactic.RingSolver.html#6999" class="Bound">nm</a> <a id="7067" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="7070" class="Symbol">(</a><a id="7071" href="Tactic.RingSolver.html#7024" class="Bound">x&#39;</a> <a id="7074" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7078" href="Tactic.RingSolver.html#7040" class="Bound">y&#39;</a> <a id="7081" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7085" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7087" class="Symbol">))</a>
      <a id="7096" href="Tactic.RingSolver.html#6942" class="CatchallClause Function">convertOp₂</a><a id="7106" class="CatchallClause"> </a><a id="7107" href="Tactic.RingSolver.html#7107" class="CatchallClause Bound">nm</a><a id="7109" class="CatchallClause"> </a><a id="7110" class="CatchallClause Symbol">(</a><a id="7111" href="Tactic.RingSolver.html#7111" class="CatchallClause Bound">x</a><a id="7112" class="CatchallClause"> </a><a id="7113" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7114" class="CatchallClause"> </a><a id="7115" href="Tactic.RingSolver.html#7115" class="CatchallClause Bound">xs</a><a id="7117" class="CatchallClause Symbol">)</a>         <a id="7127" class="Symbol">=</a> <a id="7129" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="7140" href="Tactic.RingSolver.html#7107" class="Bound">nm</a> <a id="7143" href="Tactic.RingSolver.html#7115" class="Bound">xs</a>
      <a id="7152" href="Tactic.RingSolver.html#6942" class="CatchallClause Function">convertOp₂</a><a id="7162" class="CatchallClause"> </a><a id="7163" class="CatchallClause Symbol">_</a><a id="7164" class="CatchallClause">  </a><a id="7166" class="CatchallClause Symbol">_</a>                <a id="7183" class="Symbol">=</a> <a id="7185" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7192" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7207" href="Tactic.RingSolver.html#7207" class="Function">convertOp₁</a> <a id="7218" class="Symbol">:</a> <a id="7220" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7225" class="Symbol">→</a> <a id="7227" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7232" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7237" class="Symbol">→</a> <a id="7239" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7242" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7253" href="Tactic.RingSolver.html#7207" class="Function">convertOp₁</a> <a id="7264" href="Tactic.RingSolver.html#7264" class="Bound">nm</a> <a id="7267" class="Symbol">(</a><a id="7268" href="Tactic.RingSolver.html#7268" class="Bound">x</a> <a id="7270" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7274" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7276" class="Symbol">)</a> <a id="7278" class="Symbol">=</a> <a id="7280" class="Keyword">do</a> <a id="7283" href="Tactic.RingSolver.html#7283" class="Bound">x&#39;</a> <a id="7286" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7288" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="7296" href="Tactic.RingSolver.html#7268" class="Bound">x</a><a id="7297" class="Symbol">;</a> <a id="7299" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7306" class="Symbol">(</a><a id="7307" href="Tactic.RingSolver.html#7264" class="Bound">nm</a> <a id="7310" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="7313" class="Symbol">(</a><a id="7314" href="Tactic.RingSolver.html#7283" class="Bound">x&#39;</a> <a id="7317" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7321" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7323" class="Symbol">))</a>
      <a id="7332" href="Tactic.RingSolver.html#7207" class="CatchallClause Function">convertOp₁</a><a id="7342" class="CatchallClause"> </a><a id="7343" href="Tactic.RingSolver.html#7343" class="CatchallClause Bound">nm</a><a id="7345" class="CatchallClause"> </a><a id="7346" class="CatchallClause Symbol">(</a><a id="7347" href="Tactic.RingSolver.html#7347" class="CatchallClause Bound">x</a><a id="7348" class="CatchallClause"> </a><a id="7349" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7350" class="CatchallClause"> </a><a id="7351" href="Tactic.RingSolver.html#7351" class="CatchallClause Bound">xs</a><a id="7353" class="CatchallClause Symbol">)</a>   <a id="7357" class="Symbol">=</a> <a id="7359" href="Tactic.RingSolver.html#7207" class="Function">convertOp₁</a> <a id="7370" href="Tactic.RingSolver.html#7343" class="Bound">nm</a> <a id="7373" href="Tactic.RingSolver.html#7351" class="Bound">xs</a>
      <a id="7382" href="Tactic.RingSolver.html#7207" class="CatchallClause Function">convertOp₁</a><a id="7392" class="CatchallClause"> </a><a id="7393" class="CatchallClause Symbol">_</a><a id="7394" class="CatchallClause">  </a><a id="7396" class="CatchallClause Symbol">_</a>          <a id="7407" class="Symbol">=</a> <a id="7409" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7416" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7431" href="Tactic.RingSolver.html#7431" class="Function">convertExp</a> <a id="7442" class="Symbol">:</a> <a id="7444" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7449" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7454" class="Symbol">→</a> <a id="7456" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7459" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7470" href="Tactic.RingSolver.html#7431" class="Function">convertExp</a> <a id="7481" class="Symbol">(</a><a id="7482" href="Tactic.RingSolver.html#7482" class="Bound">x</a> <a id="7484" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7488" href="Tactic.RingSolver.html#7488" class="Bound">y</a> <a id="7490" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7494" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7496" class="Symbol">)</a> <a id="7498" class="Symbol">=</a> <a id="7500" class="Keyword">do</a> <a id="7503" href="Tactic.RingSolver.html#7503" class="Bound">x&#39;</a> <a id="7506" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7508" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="7516" href="Tactic.RingSolver.html#7482" class="Bound">x</a><a id="7517" class="Symbol">;</a> <a id="7519" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7526" class="Symbol">(</a><a id="7527" class="Keyword">quote</a> <a id="7533" href="Tactic.RingSolver.Core.Expression.html#748" class="InductiveConstructor Operator">_⊛_</a> <a id="7537" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="7540" class="Symbol">(</a><a id="7541" href="Tactic.RingSolver.html#7503" class="Bound">x&#39;</a> <a id="7544" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7548" href="Tactic.RingSolver.html#7488" class="Bound">y</a> <a id="7550" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7554" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7556" class="Symbol">))</a>
      <a id="7565" href="Tactic.RingSolver.html#7431" class="CatchallClause Function">convertExp</a><a id="7575" class="CatchallClause"> </a><a id="7576" class="CatchallClause Symbol">(</a><a id="7577" href="Tactic.RingSolver.html#7577" class="CatchallClause Bound">x</a><a id="7578" class="CatchallClause"> </a><a id="7579" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7580" class="CatchallClause"> </a><a id="7581" href="Tactic.RingSolver.html#7581" class="CatchallClause Bound">xs</a><a id="7583" class="CatchallClause Symbol">)</a>         <a id="7593" class="Symbol">=</a> <a id="7595" href="Tactic.RingSolver.html#7431" class="Function">convertExp</a> <a id="7606" href="Tactic.RingSolver.html#7581" class="Bound">xs</a>
      <a id="7615" href="Tactic.RingSolver.html#7431" class="CatchallClause Function">convertExp</a><a id="7625" class="CatchallClause"> </a><a id="7626" class="CatchallClause Symbol">_</a>                <a id="7643" class="Symbol">=</a> <a id="7645" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7652" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7667" href="Tactic.RingSolver.html#7667" class="Function">convertUnknownName</a> <a id="7686" class="Symbol">:</a> <a id="7688" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7693" class="Symbol">→</a> <a id="7695" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7700" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7705" class="Symbol">→</a> <a id="7707" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7710" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7721" href="Tactic.RingSolver.html#7667" class="Function">convertUnknownName</a> <a id="7740" href="Tactic.RingSolver.html#7740" class="Bound">nm</a> <a id="7743" href="Tactic.RingSolver.html#7743" class="Bound">xs</a> <a id="7746" class="Symbol">=</a> <a id="7748" class="Keyword">do</a>
        <a id="7759" href="Tactic.RingSolver.html#7759" class="Bound">nameTerm</a> <a id="7768" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7770" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="7780" class="Symbol">(</a><a id="7781" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="7785" href="Tactic.RingSolver.html#7740" class="Bound">nm</a> <a id="7788" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7790" class="Symbol">)</a>
        <a id="7800" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="7803" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊</a> <a id="7805" href="Tactic.RingSolver.html#7759" class="Bound">nameTerm</a> <a id="7814" href="Reflection.Term.html#5163" class="Function Operator">Term.≟</a> <a id="7821" href="Tactic.RingSolver.html#2727" class="Function">+′</a> <a id="7824" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌋</a> <a id="7826" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="7831" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="7842" class="Symbol">(</a><a id="7843" class="Keyword">quote</a> <a id="7849" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="7852" class="Symbol">)</a> <a id="7854" href="Tactic.RingSolver.html#7743" class="Bound">xs</a> <a id="7857" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
          <a id="7872" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="7875" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊</a> <a id="7877" href="Tactic.RingSolver.html#7759" class="Bound">nameTerm</a> <a id="7886" href="Reflection.Term.html#5163" class="Function Operator">Term.≟</a> <a id="7893" href="Tactic.RingSolver.html#2730" class="Function">*′</a> <a id="7896" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌋</a> <a id="7898" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="7903" href="Tactic.RingSolver.html#6942" class="Function">convertOp₂</a> <a id="7914" class="Symbol">(</a><a id="7915" class="Keyword">quote</a> <a id="7921" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="7924" class="Symbol">)</a> <a id="7926" href="Tactic.RingSolver.html#7743" class="Bound">xs</a> <a id="7929" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
            <a id="7946" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="7949" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊</a> <a id="7951" href="Tactic.RingSolver.html#7759" class="Bound">nameTerm</a> <a id="7960" href="Reflection.Term.html#5163" class="Function Operator">Term.≟</a> <a id="7967" href="Tactic.RingSolver.html#2736" class="Function">-′</a> <a id="7970" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌋</a> <a id="7972" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="7977" href="Tactic.RingSolver.html#7207" class="Function">convertOp₁</a> <a id="7988" class="Symbol">(</a><a id="7989" class="Keyword">quote</a> <a id="7995" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="7997" class="Symbol">)</a>  <a id="8000" href="Tactic.RingSolver.html#7743" class="Bound">xs</a> <a id="8003" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
              <a id="8022" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8025" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊</a> <a id="8027" href="Tactic.RingSolver.html#7759" class="Bound">nameTerm</a> <a id="8036" href="Reflection.Term.html#5163" class="Function Operator">Term.≟</a> <a id="8043" href="Tactic.RingSolver.html#2733" class="Function">^′</a> <a id="8046" href="Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌋</a> <a id="8048" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8053" href="Tactic.RingSolver.html#7431" class="Function">convertExp</a>             <a id="8076" href="Tactic.RingSolver.html#7743" class="Bound">xs</a> <a id="8079" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                <a id="8100" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="8107" class="Symbol">(</a><a id="8108" href="Tactic.RingSolver.html#4666" class="Function">`Κ</a> <a id="8111" class="Symbol">(</a><a id="8112" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8116" href="Tactic.RingSolver.html#7740" class="Bound">nm</a> <a id="8119" href="Tactic.RingSolver.html#7743" class="Bound">xs</a><a id="8121" class="Symbol">))</a>

      <a id="8131" href="Tactic.RingSolver.html#8131" class="Function">convertSuc</a> <a id="8142" class="Symbol">:</a> <a id="8144" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8149" class="Symbol">→</a> <a id="8151" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8154" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8165" href="Tactic.RingSolver.html#8131" class="Function">convertSuc</a> <a id="8176" href="Tactic.RingSolver.html#8176" class="Bound">x</a> <a id="8178" class="Symbol">=</a> <a id="8180" class="Keyword">do</a> <a id="8183" href="Tactic.RingSolver.html#8183" class="Bound">x&#39;</a> <a id="8186" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="8188" href="Tactic.RingSolver.html#5979" class="Function">convert</a> <a id="8196" href="Tactic.RingSolver.html#8176" class="Bound">x</a><a id="8197" class="Symbol">;</a> <a id="8199" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="8206" class="Symbol">(</a><a id="8207" class="Keyword">quote</a> <a id="8213" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="8217" href="Tactic.RingSolver.html#4532" class="Function Operator">$ᵉ</a> <a id="8220" class="Symbol">(</a><a id="8221" href="Tactic.RingSolver.html#4666" class="Function">`Κ</a> <a id="8224" class="Symbol">(</a><a id="8225" href="Data.Nat.Reflection.html#636" class="Function">toTerm</a> <a id="8232" class="Number">1</a><a id="8233" class="Symbol">)</a> <a id="8235" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8239" href="Tactic.RingSolver.html#8183" class="Bound">x&#39;</a> <a id="8242" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8246" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8248" class="Symbol">))</a>

<a id="8252" class="Comment">------------------------------------------------------------------------</a>
<a id="8325" class="Comment">-- Macros</a>
<a id="8335" class="Comment">------------------------------------------------------------------------</a>
<a id="8408" class="Comment">-- Quantified macro</a>

<a id="8429" class="Keyword">open</a> <a id="8434" href="Tactic.RingSolver.html#2841" class="Module">RingReflection</a>
<a id="8449" class="Keyword">open</a> <a id="8454" href="Tactic.RingSolver.html#3999" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="8476" href="Tactic.RingSolver.html#8476" class="Function">malformedForallTypeError</a> <a id="8501" class="Symbol">:</a> <a id="8503" class="Symbol">∀</a> <a id="8505" class="Symbol">{</a><a id="8506" href="Tactic.RingSolver.html#8506" class="Bound">a</a><a id="8507" class="Symbol">}</a> <a id="8509" class="Symbol">{</a><a id="8510" href="Tactic.RingSolver.html#8510" class="Bound">A</a> <a id="8512" class="Symbol">:</a> <a id="8514" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8518" href="Tactic.RingSolver.html#8506" class="Bound">a</a><a id="8519" class="Symbol">}</a> <a id="8521" class="Symbol">→</a> <a id="8523" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8528" class="Symbol">→</a> <a id="8530" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8533" href="Tactic.RingSolver.html#8510" class="Bound">A</a>
<a id="8535" href="Tactic.RingSolver.html#8476" class="Function">malformedForallTypeError</a> <a id="8560" href="Tactic.RingSolver.html#8560" class="Bound">found</a> <a id="8566" class="Symbol">=</a> <a id="8568" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="8580" class="Symbol">(</a> <a id="8582" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="8589" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="8618" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8620" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="8627" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="8687" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8689" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="8696" class="String">&quot;Instead: &quot;</a>
  <a id="8710" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8712" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="8720" href="Tactic.RingSolver.html#8560" class="Bound">found</a>
  <a id="8728" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8730" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8732" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="8735" href="Tactic.RingSolver.html#8735" class="Function">quantifiedVarMap</a> <a id="8752" class="Symbol">:</a> <a id="8754" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="8756" class="Symbol">→</a> <a id="8758" href="Tactic.RingSolver.html#1684" class="Function">VarMap</a>
<a id="8765" href="Tactic.RingSolver.html#8735" class="Function">quantifiedVarMap</a> <a id="8782" href="Tactic.RingSolver.html#8782" class="Bound">numVars</a> <a id="8790" href="Tactic.RingSolver.html#8790" class="Bound">i</a> <a id="8792" class="Symbol">=</a>
  <a id="8796" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8799" href="Tactic.RingSolver.html#8790" class="Bound">i</a> <a id="8801" href="Data.Nat.Base.html#1235" class="Primitive Operator">&lt;ᵇ</a> <a id="8804" href="Tactic.RingSolver.html#8782" class="Bound">numVars</a>
    <a id="8816" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8821" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="8826" class="Symbol">(</a><a id="8827" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="8831" href="Tactic.RingSolver.html#8790" class="Bound">i</a> <a id="8833" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8835" class="Symbol">)</a>
    <a id="8841" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="8846" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="8855" href="Tactic.RingSolver.html#8855" class="Function">constructCallToSolver</a> <a id="8877" class="Symbol">:</a> <a id="8879" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8884" class="Symbol">→</a> <a id="8886" href="Tactic.RingSolver.html#2658" class="Record">RingOperatorTerms</a> <a id="8904" class="Symbol">→</a> <a id="8906" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="8911" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="8918" class="Symbol">→</a> <a id="8920" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8925" class="Symbol">→</a> <a id="8927" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8932" class="Symbol">→</a> <a id="8934" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8937" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="8942" href="Tactic.RingSolver.html#8855" class="Function">constructCallToSolver</a> <a id="8964" href="Tactic.RingSolver.html#8964" class="Bound">`ring</a> <a id="8970" href="Tactic.RingSolver.html#8970" class="Bound">opNames</a> <a id="8978" href="Tactic.RingSolver.html#8978" class="Bound">variables</a> <a id="8988" href="Tactic.RingSolver.html#8988" class="Bound">`lhs</a> <a id="8993" href="Tactic.RingSolver.html#8993" class="Bound">`rhs</a> <a id="8998" class="Symbol">=</a> <a id="9000" class="Keyword">do</a>
  <a id="9005" href="Tactic.RingSolver.html#9005" class="Bound">`lhsExpr</a> <a id="9014" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9016" href="Tactic.RingSolver.html#9540" class="Function">conv</a> <a id="9021" href="Tactic.RingSolver.html#8988" class="Bound">`lhs</a>
  <a id="9028" href="Tactic.RingSolver.html#9028" class="Bound">`rhsExpr</a> <a id="9037" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9039" href="Tactic.RingSolver.html#9540" class="Function">conv</a> <a id="9044" href="Tactic.RingSolver.html#8993" class="Bound">`rhs</a>

  <a id="9052" class="Keyword">let</a> <a id="9056" href="Tactic.RingSolver.html#9056" class="Bound">res</a> <a id="9060" class="Symbol">=</a> <a id="9062" href="Tactic.RingSolver.html#4957" class="Function">`solver</a> <a id="9070" href="Tactic.RingSolver.html#8964" class="Bound">`ring</a> <a id="9076" href="Tactic.RingSolver.html#9491" class="Function">numVars</a>
                    <a id="9104" class="Symbol">(</a><a id="9105" href="Reflection.Term.html#3452" class="Function">prependVLams</a> <a id="9118" href="Tactic.RingSolver.html#8978" class="Bound">variables</a> <a id="9128" class="Symbol">(</a><a id="9129" href="Tactic.RingSolver.html#4768" class="Function Operator">_`⊜_</a> <a id="9134" href="Tactic.RingSolver.html#8964" class="Bound">`ring</a> <a id="9140" href="Tactic.RingSolver.html#9491" class="Function">numVars</a> <a id="9148" href="Tactic.RingSolver.html#9005" class="Bound">`lhsExpr</a> <a id="9157" href="Tactic.RingSolver.html#9028" class="Bound">`rhsExpr</a><a id="9165" class="Symbol">))</a>
                    <a id="9188" class="Symbol">(</a><a id="9189" href="Reflection.Term.html#3354" class="Function">prependHLams</a> <a id="9202" href="Tactic.RingSolver.html#8978" class="Bound">variables</a> <a id="9212" class="Symbol">(</a><a id="9213" href="Tactic.RingSolver.html#3244" class="Function">`refl</a> <a id="9219" href="Tactic.RingSolver.html#8964" class="Bound">`ring</a><a id="9224" class="Symbol">))</a>
  <a id="9229" class="Comment">{-
  typeError
    ( strErr (String.unwords variables)
    ∷ strErr &quot;\n&quot;
    ∷ termErr (prependVLams variables `lhsExpr)
    ∷ strErr &quot;\n&quot;
    ∷ termErr (prependVLams variables `rhsExpr)
    ∷ strErr &quot;\n&quot;
    ∷ termErr res ∷ []
    )
  -}</a>
  <a id="9470" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="9477" href="Tactic.RingSolver.html#9056" class="Bound">res</a>
  <a id="9483" class="Keyword">where</a>
  <a id="9491" href="Tactic.RingSolver.html#9491" class="Function">numVars</a> <a id="9499" class="Symbol">:</a> <a id="9501" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
  <a id="9505" href="Tactic.RingSolver.html#9491" class="Function">numVars</a> <a id="9513" class="Symbol">=</a> <a id="9515" href="Data.List.Base.html#4864" class="Function">List.length</a> <a id="9527" href="Tactic.RingSolver.html#8978" class="Bound">variables</a>

  <a id="9540" href="Tactic.RingSolver.html#9540" class="Function">conv</a> <a id="9545" class="Symbol">:</a> <a id="9547" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9552" class="Symbol">→</a> <a id="9554" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9557" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="9564" href="Tactic.RingSolver.html#9540" class="Function">conv</a> <a id="9569" class="Symbol">=</a> <a id="9571" href="Tactic.RingSolver.html#5807" class="Function">convertTerm</a> <a id="9583" href="Tactic.RingSolver.html#8964" class="Bound">`ring</a> <a id="9589" href="Tactic.RingSolver.html#9491" class="Function">numVars</a> <a id="9597" href="Tactic.RingSolver.html#8970" class="Bound">opNames</a> <a id="9605" class="Symbol">(</a><a id="9606" href="Tactic.RingSolver.html#8735" class="Function">quantifiedVarMap</a> <a id="9623" href="Tactic.RingSolver.html#9491" class="Function">numVars</a><a id="9630" class="Symbol">)</a>

<a id="9633" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9699" class="Comment">-- variables are universally quantified over:</a>
<a id="9745" class="Comment">--</a>
<a id="9748" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="9783" class="Comment">--   lemma = solve-∀ ring</a>
<a id="9809" class="Comment">--</a>
<a id="9812" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="9875" class="Comment">-- (Find some example implementations in</a>
<a id="9916" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="9976" href="Tactic.RingSolver.html#9976" class="Function">solve-∀-macro</a> <a id="9990" class="Symbol">:</a> <a id="9992" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="9997" class="Symbol">→</a> <a id="9999" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10004" class="Symbol">→</a> <a id="10006" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10009" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="10011" href="Tactic.RingSolver.html#9976" class="Function">solve-∀-macro</a> <a id="10025" href="Tactic.RingSolver.html#10025" class="Bound">ring</a> <a id="10030" href="Tactic.RingSolver.html#10030" class="Bound">hole</a> <a id="10035" class="Symbol">=</a> <a id="10037" class="Keyword">do</a>
  <a id="10042" href="Tactic.RingSolver.html#10042" class="Bound">`ring</a> <a id="10048" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10050" href="Tactic.RingSolver.html#2747" class="Function">checkIsRing</a> <a id="10062" class="Symbol">(</a><a id="10063" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="10067" href="Tactic.RingSolver.html#10025" class="Bound">ring</a> <a id="10072" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10074" class="Symbol">)</a>
  <a id="10078" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="10089" href="Tactic.RingSolver.html#10089" class="Bound">operatorTerms</a> <a id="10103" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10105" href="Tactic.RingSolver.html#3648" class="Function">getRingOperatorTerms</a> <a id="10126" href="Tactic.RingSolver.html#10042" class="Bound">`ring</a> <a id="10132" href="Tactic.RingSolver.html#10025" class="Bound">ring</a>

  <a id="10140" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10179" href="Tactic.RingSolver.html#10179" class="Bound">`hole</a> <a id="10185" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10187" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="10197" href="Tactic.RingSolver.html#10030" class="Bound">hole</a> <a id="10202" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="10206" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="10215" class="Keyword">let</a> <a id="10219" href="Tactic.RingSolver.html#10219" class="Bound">variablesAndTypes</a> <a id="10237" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10239" href="Tactic.RingSolver.html#10239" class="Bound">equation</a> <a id="10248" class="Symbol">=</a> <a id="10250" href="Reflection.Term.html#3093" class="Function">stripPis</a> <a id="10259" href="Tactic.RingSolver.html#10179" class="Bound">`hole</a>

  <a id="10268" class="Keyword">let</a> <a id="10272" href="Tactic.RingSolver.html#10272" class="Bound">variables</a> <a id="10282" class="Symbol">=</a> <a id="10284" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="10293" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="10299" href="Tactic.RingSolver.html#10219" class="Bound">variablesAndTypes</a>
  <a id="10319" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10324" class="Symbol">(</a><a id="10325" href="Tactic.RingSolver.html#10325" class="Bound">lhs</a> <a id="10329" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10331" href="Tactic.RingSolver.html#10331" class="Bound">rhs</a> <a id="10335" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10337" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="10339" class="Symbol">)</a> <a id="10341" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10343" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="10348" class="Symbol">(</a><a id="10349" href="Tactic.RingSolver.html#1867" class="Function">getVisibleArgs</a> <a id="10364" class="Number">2</a> <a id="10366" href="Tactic.RingSolver.html#10239" class="Bound">equation</a><a id="10374" class="Symbol">)</a>
    <a id="10380" class="Keyword">where</a> <a id="10386" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="10394" class="Symbol">→</a> <a id="10396" href="Tactic.RingSolver.html#8476" class="Function">malformedForallTypeError</a> <a id="10421" href="Tactic.RingSolver.html#10179" class="Bound">`hole</a>

  <a id="10430" href="Tactic.RingSolver.html#10430" class="Bound">solverCall</a> <a id="10441" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10443" href="Tactic.RingSolver.html#8855" class="Function">constructCallToSolver</a> <a id="10465" href="Tactic.RingSolver.html#10042" class="Bound">`ring</a> <a id="10471" href="Tactic.RingSolver.html#10089" class="Bound">operatorTerms</a> <a id="10485" href="Tactic.RingSolver.html#10272" class="Bound">variables</a> <a id="10495" href="Tactic.RingSolver.html#10325" class="Bound">lhs</a> <a id="10499" href="Tactic.RingSolver.html#10331" class="Bound">rhs</a>
  <a id="10505" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="10511" href="Tactic.RingSolver.html#10030" class="Bound">hole</a> <a id="10516" href="Tactic.RingSolver.html#10430" class="Bound">solverCall</a>

<a id="10528" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10536" href="Tactic.RingSolver.html#10536" class="Function">solve-∀</a> <a id="10544" class="Symbol">:</a> <a id="10546" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10551" class="Symbol">→</a> <a id="10553" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10558" class="Symbol">→</a> <a id="10560" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10563" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="10567" href="Tactic.RingSolver.html#10536" class="Function">solve-∀</a> <a id="10575" class="Symbol">=</a> <a id="10577" href="Tactic.RingSolver.html#9976" class="Function">solve-∀-macro</a>

<a id="10592" class="Comment">------------------------------------------------------------------------</a>
<a id="10665" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10688" href="Tactic.RingSolver.html#10688" class="Function">malformedArgumentListError</a> <a id="10715" class="Symbol">:</a> <a id="10717" class="Symbol">∀</a> <a id="10719" class="Symbol">{</a><a id="10720" href="Tactic.RingSolver.html#10720" class="Bound">a</a><a id="10721" class="Symbol">}</a> <a id="10723" class="Symbol">{</a><a id="10724" href="Tactic.RingSolver.html#10724" class="Bound">A</a> <a id="10726" class="Symbol">:</a> <a id="10728" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="10732" href="Tactic.RingSolver.html#10720" class="Bound">a</a><a id="10733" class="Symbol">}</a> <a id="10735" class="Symbol">→</a> <a id="10737" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10742" class="Symbol">→</a> <a id="10744" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10747" href="Tactic.RingSolver.html#10724" class="Bound">A</a>
<a id="10749" href="Tactic.RingSolver.html#10688" class="Function">malformedArgumentListError</a> <a id="10776" href="Tactic.RingSolver.html#10776" class="Bound">found</a> <a id="10782" class="Symbol">=</a> <a id="10784" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="10796" class="Symbol">(</a> <a id="10798" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="10805" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="10834" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="10836" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="10843" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="10898" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="10900" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="10907" class="String">&quot;Instead: &quot;</a>
  <a id="10921" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="10923" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="10931" href="Tactic.RingSolver.html#10776" class="Bound">found</a>
  <a id="10939" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="10941" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10943" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="10946" href="Tactic.RingSolver.html#10946" class="Function">malformedGoalError</a> <a id="10965" class="Symbol">:</a> <a id="10967" class="Symbol">∀</a> <a id="10969" class="Symbol">{</a><a id="10970" href="Tactic.RingSolver.html#10970" class="Bound">a</a><a id="10971" class="Symbol">}</a> <a id="10973" class="Symbol">{</a><a id="10974" href="Tactic.RingSolver.html#10974" class="Bound">A</a> <a id="10976" class="Symbol">:</a> <a id="10978" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="10982" href="Tactic.RingSolver.html#10970" class="Bound">a</a><a id="10983" class="Symbol">}</a> <a id="10985" class="Symbol">→</a> <a id="10987" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10992" class="Symbol">→</a> <a id="10994" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10997" href="Tactic.RingSolver.html#10974" class="Bound">A</a>
<a id="10999" href="Tactic.RingSolver.html#10946" class="Function">malformedGoalError</a> <a id="11018" href="Tactic.RingSolver.html#11018" class="Bound">found</a> <a id="11024" class="Symbol">=</a> <a id="11026" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11038" class="Symbol">(</a> <a id="11040" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11047" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11076" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11078" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11085" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11132" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11134" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11141" class="String">&quot;Instead: &quot;</a>
  <a id="11155" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11157" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11165" href="Tactic.RingSolver.html#11018" class="Bound">found</a>
  <a id="11173" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11175" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11177" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11180" href="Tactic.RingSolver.html#11180" class="Function">checkIsListOfVariables</a> <a id="11203" class="Symbol">:</a> <a id="11205" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11210" class="Symbol">→</a> <a id="11212" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11217" class="Symbol">→</a> <a id="11219" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11222" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11227" href="Tactic.RingSolver.html#11180" class="Function">checkIsListOfVariables</a> <a id="11250" href="Tactic.RingSolver.html#11250" class="Bound">`ring</a> <a id="11256" href="Tactic.RingSolver.html#11256" class="Bound">`xs</a> <a id="11260" class="Symbol">=</a> <a id="11262" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="11272" href="Tactic.RingSolver.html#11256" class="Bound">`xs</a> <a id="11276" class="Symbol">(</a><a id="11277" href="Data.List.Reflection.html#454" class="Function">`List</a> <a id="11283" class="Symbol">(</a><a id="11284" href="Tactic.RingSolver.html#3192" class="Function">`Carrier</a> <a id="11293" href="Tactic.RingSolver.html#11250" class="Bound">`ring</a><a id="11298" class="Symbol">))</a> <a id="11301" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="11305" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a>

<a id="11316" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11374" href="Tactic.RingSolver.html#11374" class="Function">getVariableIndices</a> <a id="11393" class="Symbol">:</a> <a id="11395" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11400" class="Symbol">→</a> <a id="11402" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11408" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
<a id="11415" href="Tactic.RingSolver.html#11374" class="Function">getVariableIndices</a> <a id="11434" class="Symbol">=</a> <a id="11436" href="Tactic.RingSolver.html#11452" class="Function">go</a> <a id="11439" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="11444" class="Keyword">where</a>
  <a id="11452" href="Tactic.RingSolver.html#11452" class="Function">go</a> <a id="11455" class="Symbol">:</a> <a id="11457" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11464" class="Symbol">→</a> <a id="11466" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11471" class="Symbol">→</a> <a id="11473" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11479" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
  <a id="11488" href="Tactic.RingSolver.html#11452" class="Function">go</a> <a id="11491" href="Tactic.RingSolver.html#11491" class="Bound">t</a> <a id="11493" class="Symbol">(</a><a id="11494" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="11498" href="Tactic.RingSolver.html#11498" class="Bound">i</a> <a id="11500" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="11503" href="Data.List.Reflection.html#948" class="InductiveConstructor Operator">`∷`</a> <a id="11507" href="Tactic.RingSolver.html#11507" class="Bound">xs</a><a id="11509" class="Symbol">)</a> <a id="11511" class="Symbol">=</a> <a id="11513" href="Tactic.RingSolver.html#11452" class="Function">go</a> <a id="11516" class="Symbol">(</a><a id="11517" href="Tactic.RingSolver.Core.NatSet.html#2233" class="Function">insert</a> <a id="11524" href="Tactic.RingSolver.html#11498" class="Bound">i</a> <a id="11526" href="Tactic.RingSolver.html#11491" class="Bound">t</a><a id="11527" class="Symbol">)</a> <a id="11529" href="Tactic.RingSolver.html#11507" class="Bound">xs</a>
  <a id="11534" href="Tactic.RingSolver.html#11452" class="Function">go</a> <a id="11537" href="Tactic.RingSolver.html#11537" class="Bound">t</a> <a id="11539" href="Data.List.Reflection.html#904" class="InductiveConstructor">`[]`</a>              <a id="11557" class="Symbol">=</a> <a id="11559" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="11564" href="Tactic.RingSolver.html#11537" class="Bound">t</a>
  <a id="11568" href="Tactic.RingSolver.html#11452" class="CatchallClause Function">go</a><a id="11570" class="CatchallClause"> </a><a id="11571" class="CatchallClause Symbol">_</a><a id="11572" class="CatchallClause"> </a><a id="11573" class="CatchallClause Symbol">_</a>                 <a id="11591" class="Symbol">=</a> <a id="11593" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11602" href="Tactic.RingSolver.html#11602" class="Function">constructSolution</a> <a id="11620" class="Symbol">:</a> <a id="11622" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11627" class="Symbol">→</a> <a id="11629" href="Tactic.RingSolver.html#2658" class="Record">RingOperatorTerms</a> <a id="11647" class="Symbol">→</a> <a id="11649" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11656" class="Symbol">→</a> <a id="11658" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11663" class="Symbol">→</a> <a id="11665" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11670" class="Symbol">→</a> <a id="11672" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11675" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11680" href="Tactic.RingSolver.html#11602" class="Function">constructSolution</a> <a id="11698" href="Tactic.RingSolver.html#11698" class="Bound">`ring</a> <a id="11704" href="Tactic.RingSolver.html#11704" class="Bound">opTerms</a> <a id="11712" href="Tactic.RingSolver.html#11712" class="Bound">variables</a> <a id="11722" href="Tactic.RingSolver.html#11722" class="Bound">`lhs</a> <a id="11727" href="Tactic.RingSolver.html#11727" class="Bound">`rhs</a> <a id="11732" class="Symbol">=</a> <a id="11734" class="Keyword">do</a>
  <a id="11739" href="Tactic.RingSolver.html#11739" class="Bound">`lhsExpr</a> <a id="11748" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="11750" href="Tactic.RingSolver.html#12025" class="Function">conv</a> <a id="11755" href="Tactic.RingSolver.html#11722" class="Bound">`lhs</a>
  <a id="11762" href="Tactic.RingSolver.html#11762" class="Bound">`rhsExpr</a> <a id="11771" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="11773" href="Tactic.RingSolver.html#12025" class="Function">conv</a> <a id="11778" href="Tactic.RingSolver.html#11727" class="Bound">`rhs</a>
  <a id="11785" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="11792" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="11794" href="Tactic.RingSolver.html#3364" class="Function">`trans</a> <a id="11801" href="Tactic.RingSolver.html#11698" class="Bound">`ring</a> <a id="11807" class="Symbol">(</a><a id="11808" href="Tactic.RingSolver.html#3296" class="Function">`sym</a> <a id="11813" href="Tactic.RingSolver.html#11698" class="Bound">`ring</a> <a id="11819" href="Tactic.RingSolver.html#11739" class="Bound">`lhsExpr</a><a id="11827" class="Symbol">)</a> <a id="11829" href="Tactic.RingSolver.html#11762" class="Bound">`rhsExpr</a>
  <a id="11840" class="Keyword">where</a>
  <a id="11848" href="Tactic.RingSolver.html#11848" class="Function">numVars</a> <a id="11856" class="Symbol">=</a> <a id="11858" href="Data.List.Base.html#4864" class="Function">List.length</a> <a id="11870" href="Tactic.RingSolver.html#11712" class="Bound">variables</a>

  <a id="11883" href="Tactic.RingSolver.html#11883" class="Function">varMap</a> <a id="11890" class="Symbol">:</a> <a id="11892" href="Tactic.RingSolver.html#1684" class="Function">VarMap</a>
  <a id="11901" href="Tactic.RingSolver.html#11883" class="Function">varMap</a> <a id="11908" href="Tactic.RingSolver.html#11908" class="Bound">i</a> <a id="11910" class="Symbol">=</a> <a id="11912" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="11922" class="Symbol">(λ</a> <a id="11925" href="Tactic.RingSolver.html#11925" class="Bound">x</a> <a id="11927" class="Symbol">→</a> <a id="11929" href="Tactic.RingSolver.html#4717" class="Function">`I</a> <a id="11932" href="Tactic.RingSolver.html#11698" class="Bound">`ring</a> <a id="11938" href="Tactic.RingSolver.html#11848" class="Function">numVars</a> <a id="11946" class="Symbol">(</a><a id="11947" href="Data.Nat.Reflection.html#711" class="Function">toFinTerm</a> <a id="11957" href="Tactic.RingSolver.html#11925" class="Bound">x</a><a id="11958" class="Symbol">))</a> <a id="11961" class="Symbol">(</a><a id="11962" href="Tactic.RingSolver.Core.NatSet.html#2881" class="Function">lookup</a> <a id="11969" href="Tactic.RingSolver.html#11908" class="Bound">i</a> <a id="11971" href="Tactic.RingSolver.html#11712" class="Bound">variables</a><a id="11980" class="Symbol">)</a>

  <a id="11985" href="Tactic.RingSolver.html#11985" class="Function">ρ</a> <a id="11987" class="Symbol">:</a> <a id="11989" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="11996" href="Tactic.RingSolver.html#11985" class="Function">ρ</a> <a id="11998" class="Symbol">=</a> <a id="12000" href="Tactic.RingSolver.html#2290" class="Function">curriedTerm</a> <a id="12012" href="Tactic.RingSolver.html#11712" class="Bound">variables</a>

  <a id="12025" href="Tactic.RingSolver.html#12025" class="Function">conv</a> <a id="12030" class="Symbol">=</a> <a id="12032" class="Symbol">λ</a> <a id="12034" href="Tactic.RingSolver.html#12034" class="Bound">t</a> <a id="12036" class="Symbol">→</a> <a id="12038" class="Keyword">do</a>
    <a id="12045" href="Tactic.RingSolver.html#12045" class="Bound">t&#39;</a> <a id="12048" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12050" href="Tactic.RingSolver.html#5807" class="Function">convertTerm</a> <a id="12062" href="Tactic.RingSolver.html#11698" class="Bound">`ring</a> <a id="12068" href="Tactic.RingSolver.html#11848" class="Function">numVars</a> <a id="12076" href="Tactic.RingSolver.html#11704" class="Bound">opTerms</a> <a id="12084" href="Tactic.RingSolver.html#11883" class="Function">varMap</a> <a id="12091" href="Tactic.RingSolver.html#12034" class="Bound">t</a>
    <a id="12097" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="12104" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12106" href="Tactic.RingSolver.html#4862" class="Function">`correct</a> <a id="12115" href="Tactic.RingSolver.html#11698" class="Bound">`ring</a> <a id="12121" href="Tactic.RingSolver.html#11848" class="Function">numVars</a> <a id="12129" href="Tactic.RingSolver.html#12045" class="Bound">t&#39;</a> <a id="12132" href="Tactic.RingSolver.html#11985" class="Function">ρ</a>

<a id="12135" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="12217" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="12292" class="Comment">-- intermediate step. Call it like so:</a>
<a id="12331" class="Comment">--</a>
<a id="12334" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12386" class="Comment">--   lemma₃ x y = begin</a>
<a id="12410" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12469" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12523" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12554" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12577" class="Comment">--</a>
<a id="12580" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12647" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12683" href="Tactic.RingSolver.html#12683" class="Function">solve-macro</a> <a id="12695" class="Symbol">:</a> <a id="12697" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12702" class="Symbol">→</a> <a id="12704" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="12709" class="Symbol">→</a> <a id="12711" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12716" class="Symbol">→</a> <a id="12718" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="12721" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="12723" href="Tactic.RingSolver.html#12683" class="Function">solve-macro</a> <a id="12735" href="Tactic.RingSolver.html#12735" class="Bound">variables</a> <a id="12745" href="Tactic.RingSolver.html#12745" class="Bound">ring</a> <a id="12750" href="Tactic.RingSolver.html#12750" class="Bound">hole</a> <a id="12755" class="Symbol">=</a> <a id="12757" class="Keyword">do</a>
  <a id="12762" href="Tactic.RingSolver.html#12762" class="Bound">`ring</a> <a id="12768" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12770" href="Tactic.RingSolver.html#2747" class="Function">checkIsRing</a> <a id="12782" class="Symbol">(</a><a id="12783" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="12787" href="Tactic.RingSolver.html#12745" class="Bound">ring</a> <a id="12792" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="12794" class="Symbol">)</a>
  <a id="12798" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="12809" href="Tactic.RingSolver.html#12809" class="Bound">operatorTerms</a> <a id="12823" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12825" href="Tactic.RingSolver.html#3648" class="Function">getRingOperatorTerms</a> <a id="12846" href="Tactic.RingSolver.html#12762" class="Bound">`ring</a> <a id="12852" href="Tactic.RingSolver.html#12745" class="Bound">ring</a>

  <a id="12860" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="12907" href="Tactic.RingSolver.html#12907" class="Bound">listOfVariables′</a> <a id="12924" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12926" href="Tactic.RingSolver.html#11180" class="Function">checkIsListOfVariables</a> <a id="12949" href="Tactic.RingSolver.html#12762" class="Bound">`ring</a> <a id="12955" href="Tactic.RingSolver.html#12735" class="Bound">variables</a>
  <a id="12967" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="12978" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="12983" href="Tactic.RingSolver.html#12983" class="Bound">variableIndices</a> <a id="12999" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13001" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="13006" class="Symbol">(</a><a id="13007" href="Tactic.RingSolver.html#11374" class="Function">getVariableIndices</a> <a id="13026" href="Tactic.RingSolver.html#12907" class="Bound">listOfVariables′</a><a id="13042" class="Symbol">)</a>
    <a id="13048" class="Keyword">where</a> <a id="13054" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13062" class="Symbol">→</a> <a id="13064" href="Tactic.RingSolver.html#10688" class="Function">malformedArgumentListError</a> <a id="13091" href="Tactic.RingSolver.html#12907" class="Bound">listOfVariables′</a>

  <a id="13111" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13149" href="Tactic.RingSolver.html#13149" class="Bound">hole′</a> <a id="13155" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13157" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="13167" href="Tactic.RingSolver.html#12750" class="Bound">hole</a> <a id="13172" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="13176" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="13185" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13190" class="Symbol">(</a><a id="13191" href="Tactic.RingSolver.html#13191" class="Bound">lhs</a> <a id="13195" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="13197" href="Tactic.RingSolver.html#13197" class="Bound">rhs</a> <a id="13201" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="13203" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="13205" class="Symbol">)</a> <a id="13207" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13209" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="13214" class="Symbol">(</a><a id="13215" href="Tactic.RingSolver.html#1867" class="Function">getVisibleArgs</a> <a id="13230" class="Number">2</a> <a id="13232" href="Tactic.RingSolver.html#13149" class="Bound">hole′</a><a id="13237" class="Symbol">)</a>
    <a id="13243" class="Keyword">where</a> <a id="13249" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13257" class="Symbol">→</a> <a id="13259" href="Tactic.RingSolver.html#10946" class="Function">malformedGoalError</a> <a id="13278" href="Tactic.RingSolver.html#13149" class="Bound">hole′</a>

  <a id="13287" href="Tactic.RingSolver.html#13287" class="Bound">solution</a> <a id="13296" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13298" href="Tactic.RingSolver.html#11602" class="Function">constructSolution</a> <a id="13316" href="Tactic.RingSolver.html#12762" class="Bound">`ring</a> <a id="13322" href="Tactic.RingSolver.html#12809" class="Bound">operatorTerms</a> <a id="13336" href="Tactic.RingSolver.html#12983" class="Bound">variableIndices</a> <a id="13352" href="Tactic.RingSolver.html#13191" class="Bound">lhs</a> <a id="13356" href="Tactic.RingSolver.html#13197" class="Bound">rhs</a>
  <a id="13362" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="13368" href="Tactic.RingSolver.html#12750" class="Bound">hole</a> <a id="13373" href="Tactic.RingSolver.html#13287" class="Bound">solution</a>

<a id="13383" class="Keyword">macro</a>
  <a id="solve"></a><a id="13391" href="Tactic.RingSolver.html#13391" class="Function">solve</a> <a id="13397" class="Symbol">:</a> <a id="13399" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13404" class="Symbol">→</a> <a id="13406" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="13411" class="Symbol">→</a> <a id="13413" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13418" class="Symbol">→</a> <a id="13420" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="13423" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="13427" href="Tactic.RingSolver.html#13391" class="Function">solve</a> <a id="13433" class="Symbol">=</a> <a id="13435" href="Tactic.RingSolver.html#12683" class="Function">solve-macro</a>
</pre></body></html>