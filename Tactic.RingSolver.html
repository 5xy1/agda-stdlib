<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--without-K</a> <a id="296" class="Pragma">--safe</a> <a id="303" class="Symbol">#-}</a>

<a id="308" class="Keyword">module</a> <a id="315" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="333" class="Keyword">where</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Algebra.html" class="Module">Algebra</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="388" class="Symbol">as</a> <a id="391" class="Module">Fin</a>   <a id="397" class="Keyword">using</a> <a id="403" class="Symbol">(</a><a id="404" href="Data.Fin.Base.html#1214" class="Datatype">Fin</a><a id="407" class="Symbol">)</a>
<a id="409" class="Keyword">open</a> <a id="414" class="Keyword">import</a> <a id="421" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="437" class="Symbol">as</a> <a id="440" class="Module">Vec</a>   <a id="446" class="Keyword">using</a> <a id="452" class="Symbol">(</a><a id="453" href="Data.Vec.Base.html#1036" class="Datatype">Vec</a><a id="456" class="Symbol">;</a> <a id="458" href="Data.Vec.Base.html#1091" class="InductiveConstructor Operator">_∷_</a><a id="461" class="Symbol">;</a> <a id="463" href="Data.Vec.Base.html#1072" class="InductiveConstructor">[]</a><a id="465" class="Symbol">)</a>
<a id="467" class="Keyword">open</a> <a id="472" class="Keyword">import</a> <a id="479" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="495" class="Symbol">as</a> <a id="498" class="Module">List</a>  <a id="504" class="Keyword">using</a> <a id="510" class="Symbol">(</a><a id="511" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="515" class="Symbol">;</a> <a id="517" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="520" class="Symbol">;</a> <a id="522" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="524" class="Symbol">)</a>
<a id="526" class="Keyword">open</a> <a id="531" class="Keyword">import</a> <a id="538" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="554" class="Symbol">as</a> <a id="557" class="Module">Maybe</a> <a id="563" class="Keyword">using</a> <a id="569" class="Symbol">(</a><a id="570" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="575" class="Symbol">;</a> <a id="577" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="581" class="Symbol">;</a> <a id="583" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="590" class="Symbol">;</a> <a id="592" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a><a id="601" class="Symbol">)</a>
<a id="603" class="Keyword">open</a> <a id="608" class="Keyword">import</a> <a id="615" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>            <a id="640" class="Keyword">using</a> <a id="646" class="Symbol">(</a><a id="647" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="648" class="Symbol">;</a> <a id="650" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="653" class="Symbol">;</a> <a id="655" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="659" class="Symbol">;</a> <a id="661" href="Data.Nat.Base.html#1230" class="Primitive Operator">_&lt;ᵇ_</a><a id="665" class="Symbol">)</a>
<a id="667" class="Keyword">open</a> <a id="672" class="Keyword">import</a> <a id="679" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>           <a id="704" class="Keyword">using</a> <a id="710" class="Symbol">(</a><a id="711" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="715" class="Symbol">;</a> <a id="717" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="730" class="Symbol">;</a> <a id="732" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="736" class="Symbol">;</a> <a id="738" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="743" class="Symbol">)</a>
<a id="745" class="Keyword">open</a> <a id="750" class="Keyword">import</a> <a id="757" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>           <a id="782" class="Keyword">using</a> <a id="788" class="Symbol">(</a><a id="789" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="790" class="Symbol">)</a>
<a id="792" class="Keyword">open</a> <a id="797" class="Keyword">import</a> <a id="804" href="Data.String.html" class="Module">Data.String</a> <a id="816" class="Symbol">as</a> <a id="819" class="Module">String</a>    <a id="829" class="Keyword">using</a> <a id="835" class="Symbol">(</a><a id="836" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="842" class="Symbol">;</a> <a id="844" href="Data.String.Base.html#2366" class="Function Operator">_++_</a><a id="848" class="Symbol">;</a> <a id="850" href="Data.String.Base.html#2826" class="Function">parens</a><a id="856" class="Symbol">)</a>
<a id="858" class="Keyword">open</a> <a id="863" class="Keyword">import</a> <a id="870" href="Data.Product.html" class="Module">Data.Product</a>             <a id="895" class="Keyword">using</a> <a id="901" class="Symbol">(</a><a id="902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="905" class="Symbol">;</a> <a id="907" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="912" class="Symbol">)</a>
<a id="914" class="Keyword">open</a> <a id="919" class="Keyword">import</a> <a id="926" href="Function.html" class="Module">Function</a>
<a id="935" class="Keyword">open</a> <a id="940" class="Keyword">import</a> <a id="947" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="975" class="Keyword">open</a> <a id="980" class="Keyword">import</a> <a id="987" href="Reflection.html" class="Module">Reflection</a>
<a id="998" class="Keyword">open</a> <a id="1003" class="Keyword">import</a> <a id="1010" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="1034" class="Keyword">open</a> <a id="1039" class="Keyword">import</a> <a id="1046" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a> <a id="1066" class="Symbol">as</a> <a id="1069" class="Module">Term</a>
<a id="1074" class="Keyword">open</a> <a id="1079" class="Keyword">import</a> <a id="1086" href="Reflection.AST.AlphaEquality.html" class="Module">Reflection.AST.AlphaEquality</a>
<a id="1115" class="Keyword">open</a> <a id="1120" class="Keyword">import</a> <a id="1127" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="1147" class="Symbol">as</a> <a id="1150" class="Module">Name</a>
<a id="1155" class="Keyword">open</a> <a id="1160" class="Keyword">import</a> <a id="1167" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>
<a id="1189" class="Keyword">open</a> <a id="1194" class="Keyword">import</a> <a id="1201" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1221" class="Keyword">open</a> <a id="1226" class="Keyword">import</a> <a id="1233" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1254" class="Keyword">import</a> <a id="1261" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1281" class="Symbol">as</a> <a id="1284" class="Module">Vec</a>

<a id="1289" class="Keyword">open</a> <a id="1294" class="Keyword">import</a> <a id="1301" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1333" class="Keyword">renaming</a> <a id="1342" class="Symbol">(</a><a id="1343" href="Tactic.RingSolver.NonReflective.html#2953" class="Function">solve</a> <a id="1349" class="Symbol">to</a> <a id="1352" class="Function">solver</a><a id="1358" class="Symbol">)</a>
<a id="1360" class="Keyword">open</a> <a id="1365" class="Keyword">import</a> <a id="1372" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1417" class="Keyword">open</a> <a id="1422" class="Keyword">import</a> <a id="1429" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1459" class="Symbol">as</a> <a id="1462" class="Module">NatSet</a>

<a id="1470" class="Keyword">open</a> <a id="1475" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Module">AlmostCommutativeRing</a>

<a id="1498" class="Comment">------------------------------------------------------------------------</a>
<a id="1571" class="Comment">-- Utilities</a>

<a id="1585" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1595" href="Tactic.RingSolver.html#1595" class="Function">VarMap</a> <a id="1602" class="Symbol">:</a> <a id="1604" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="1610" href="Tactic.RingSolver.html#1595" class="Function">VarMap</a> <a id="1617" class="Symbol">=</a> <a id="1619" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1621" class="Symbol">→</a> <a id="1623" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1629" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1637" href="Tactic.RingSolver.html#1637" class="Function">getVisible</a> <a id="1648" class="Symbol">:</a> <a id="1650" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="1654" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1659" class="Symbol">→</a> <a id="1661" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1667" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="1674" href="Tactic.RingSolver.html#1637" class="Function">getVisible</a> <a id="1685" class="Symbol">(</a><a id="1686" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="1690" class="Symbol">(</a><a id="1691" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="1700" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="1708" class="Symbol">_)</a> <a id="1711" href="Tactic.RingSolver.html#1711" class="Bound">x</a><a id="1712" class="Symbol">)</a> <a id="1714" class="Symbol">=</a> <a id="1716" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1721" href="Tactic.RingSolver.html#1711" class="Bound">x</a>
  <a id="1725" href="Tactic.RingSolver.html#1637" class="CatchallClause Function">getVisible</a><a id="1735" class="CatchallClause"> </a><a id="1736" class="CatchallClause Symbol">_</a>                            <a id="1765" class="Symbol">=</a> <a id="1767" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1778" href="Tactic.RingSolver.html#1778" class="Function">getVisibleArgs</a> <a id="1793" class="Symbol">:</a> <a id="1795" class="Symbol">∀</a> <a id="1797" href="Tactic.RingSolver.html#1797" class="Bound">n</a> <a id="1799" class="Symbol">→</a> <a id="1801" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1806" class="Symbol">→</a> <a id="1808" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1814" class="Symbol">(</a><a id="1815" href="Data.Vec.Base.html#1036" class="Datatype">Vec</a> <a id="1819" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1824" href="Tactic.RingSolver.html#1797" class="Bound">n</a><a id="1825" class="Symbol">)</a>
  <a id="1829" href="Tactic.RingSolver.html#1778" class="Function">getVisibleArgs</a> <a id="1844" href="Tactic.RingSolver.html#1844" class="Bound">n</a> <a id="1846" class="Symbol">(</a><a id="1847" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="1851" class="Symbol">_</a> <a id="1853" href="Tactic.RingSolver.html#1853" class="Bound">xs</a><a id="1855" class="Symbol">)</a> <a id="1857" class="Symbol">=</a> <a id="1859" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="1869" href="Data.Vec.Base.html#8564" class="Function">Vec.reverse</a>
    <a id="1885" class="Symbol">(</a><a id="1886" href="Data.List.Base.html#4293" class="Function">List.foldl</a> <a id="1897" href="Tactic.RingSolver.html#1948" class="Function">f</a> <a id="1899" href="Tactic.RingSolver.html#2092" class="Function">c</a> <a id="1901" class="Symbol">(</a><a id="1902" href="Data.List.Base.html#1629" class="Function">List.mapMaybe</a> <a id="1916" href="Tactic.RingSolver.html#1637" class="Function">getVisible</a> <a id="1927" href="Tactic.RingSolver.html#1853" class="Bound">xs</a><a id="1929" class="Symbol">)</a> <a id="1931" href="Tactic.RingSolver.html#1844" class="Bound">n</a><a id="1932" class="Symbol">)</a>
    <a id="1938" class="Keyword">where</a>
    <a id="1948" href="Tactic.RingSolver.html#1948" class="Function">f</a> <a id="1950" class="Symbol">:</a> <a id="1952" class="Symbol">(∀</a> <a id="1955" href="Tactic.RingSolver.html#1955" class="Bound">n</a> <a id="1957" class="Symbol">→</a> <a id="1959" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1965" class="Symbol">(</a><a id="1966" href="Data.Vec.Base.html#1036" class="Datatype">Vec</a> <a id="1970" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1975" href="Tactic.RingSolver.html#1955" class="Bound">n</a><a id="1976" class="Symbol">))</a> <a id="1979" class="Symbol">→</a> <a id="1981" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1986" class="Symbol">→</a> <a id="1988" class="Symbol">∀</a> <a id="1990" href="Tactic.RingSolver.html#1990" class="Bound">n</a> <a id="1992" class="Symbol">→</a> <a id="1994" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2000" class="Symbol">(</a><a id="2001" href="Data.Vec.Base.html#1036" class="Datatype">Vec</a> <a id="2005" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2010" href="Tactic.RingSolver.html#1990" class="Bound">n</a><a id="2011" class="Symbol">)</a>
    <a id="2017" href="Tactic.RingSolver.html#1948" class="Function">f</a> <a id="2019" href="Tactic.RingSolver.html#2019" class="Bound">xs</a> <a id="2022" href="Tactic.RingSolver.html#2022" class="Bound">x</a> <a id="2024" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2032" class="Symbol">=</a> <a id="2034" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2039" href="Data.Vec.Base.html#1072" class="InductiveConstructor">[]</a>
    <a id="2046" href="Tactic.RingSolver.html#1948" class="Function">f</a> <a id="2048" href="Tactic.RingSolver.html#2048" class="Bound">xs</a> <a id="2051" href="Tactic.RingSolver.html#2051" class="Bound">x</a> <a id="2053" class="Symbol">(</a><a id="2054" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2058" href="Tactic.RingSolver.html#2058" class="Bound">n</a><a id="2059" class="Symbol">)</a> <a id="2061" class="Symbol">=</a> <a id="2063" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="2073" class="Symbol">(</a><a id="2074" href="Tactic.RingSolver.html#2051" class="Bound">x</a> <a id="2076" href="Data.Vec.Base.html#1091" class="InductiveConstructor Operator">∷_</a><a id="2078" class="Symbol">)</a> <a id="2080" class="Symbol">(</a><a id="2081" href="Tactic.RingSolver.html#2048" class="Bound">xs</a> <a id="2084" href="Tactic.RingSolver.html#2058" class="Bound">n</a><a id="2085" class="Symbol">)</a>

    <a id="2092" href="Tactic.RingSolver.html#2092" class="Function">c</a> <a id="2094" class="Symbol">:</a> <a id="2096" class="Symbol">∀</a> <a id="2098" href="Tactic.RingSolver.html#2098" class="Bound">n</a> <a id="2100" class="Symbol">→</a> <a id="2102" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2108" class="Symbol">(</a><a id="2109" href="Data.Vec.Base.html#1036" class="Datatype">Vec</a> <a id="2113" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2118" href="Tactic.RingSolver.html#2098" class="Bound">n</a><a id="2119" class="Symbol">)</a>
    <a id="2125" href="Tactic.RingSolver.html#2092" class="Function">c</a> <a id="2127" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="2136" class="Symbol">=</a> <a id="2138" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2143" href="Data.Vec.Base.html#1072" class="InductiveConstructor">[]</a>
    <a id="2150" href="Tactic.RingSolver.html#2092" class="Function">c</a> <a id="2152" class="Symbol">(</a><a id="2153" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2157" class="Symbol">_</a> <a id="2159" class="Symbol">)</a> <a id="2161" class="Symbol">=</a> <a id="2163" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
  <a id="2173" href="Tactic.RingSolver.html#1778" class="CatchallClause Function">getVisibleArgs</a><a id="2187" class="CatchallClause"> </a><a id="2188" class="CatchallClause Symbol">_</a><a id="2189" class="CatchallClause"> </a><a id="2190" class="CatchallClause Symbol">_</a> <a id="2192" class="Symbol">=</a> <a id="2194" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2205" href="Tactic.RingSolver.html#2205" class="Function">curriedTerm</a> <a id="2217" class="Symbol">:</a> <a id="2219" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="2226" class="Symbol">→</a> <a id="2228" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="2235" href="Tactic.RingSolver.html#2205" class="Function">curriedTerm</a> <a id="2247" class="Symbol">=</a> <a id="2249" href="Data.List.Base.html#4192" class="Function">List.foldr</a> <a id="2260" href="Tactic.RingSolver.html#2301" class="Function">go</a> <a id="2263" href="Data.Vec.Reflection.html#670" class="Function">Vec.`[]</a> <a id="2271" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2273" href="Tactic.RingSolver.Core.NatSet.html#3284" class="Function">NatSet.toList</a>
    <a id="2291" class="Keyword">where</a>
    <a id="2301" href="Tactic.RingSolver.html#2301" class="Function">go</a> <a id="2304" class="Symbol">:</a> <a id="2306" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2308" class="Symbol">→</a> <a id="2310" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2315" class="Symbol">→</a> <a id="2317" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
    <a id="2326" href="Tactic.RingSolver.html#2301" class="Function">go</a> <a id="2329" href="Tactic.RingSolver.html#2329" class="Bound">x</a> <a id="2331" href="Tactic.RingSolver.html#2331" class="Bound">xs</a> <a id="2334" class="Symbol">=</a> <a id="2336" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="2340" href="Tactic.RingSolver.html#2329" class="Bound">x</a> <a id="2342" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2345" href="Data.Vec.Reflection.html#720" class="Function Operator">Vec.`∷</a> <a id="2352" href="Tactic.RingSolver.html#2331" class="Bound">xs</a>

<a id="2356" class="Comment">------------------------------------------------------------------------</a>
<a id="2429" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2464" href="Tactic.RingSolver.html#2464" class="Function">`AlmostCommutativeRing</a> <a id="2487" class="Symbol">:</a> <a id="2489" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2494" href="Tactic.RingSolver.html#2464" class="Function">`AlmostCommutativeRing</a> <a id="2517" class="Symbol">=</a> <a id="2519" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="2523" class="Symbol">(</a><a id="2524" class="Keyword">quote</a> <a id="2530" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Record">AlmostCommutativeRing</a><a id="2551" class="Symbol">)</a> <a id="2553" class="Symbol">(</a><a id="2554" class="Number">2</a> <a id="2556" href="Reflection.AST.Term.html#2519" class="Function Operator">⋯⟨∷⟩</a> <a id="2561" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2563" class="Symbol">)</a>

<a id="2566" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2573" href="Tactic.RingSolver.html#2573" class="Record">RingOperatorTerms</a> <a id="2591" class="Symbol">:</a> <a id="2593" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2597" class="Keyword">where</a>
  <a id="2605" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2617" href="Tactic.RingSolver.html#2617" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2645" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2655" href="Tactic.RingSolver.html#2655" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2659" href="Tactic.RingSolver.html#2659" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2663" href="Tactic.RingSolver.html#2663" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2667" href="Tactic.RingSolver.html#2667" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2671" href="Tactic.RingSolver.html#2671" class="Field">sub</a> <a id="2675" class="Symbol">:</a> <a id="2677" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2683" href="Tactic.RingSolver.html#2683" class="Function">checkIsRing</a> <a id="2695" class="Symbol">:</a> <a id="2697" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2702" class="Symbol">→</a> <a id="2704" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="2707" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2712" href="Tactic.RingSolver.html#2683" class="Function">checkIsRing</a> <a id="2724" href="Tactic.RingSolver.html#2724" class="Bound">ring</a> <a id="2729" class="Symbol">=</a> <a id="2731" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="2741" href="Tactic.RingSolver.html#2724" class="Bound">ring</a> <a id="2746" href="Tactic.RingSolver.html#2464" class="Function">`AlmostCommutativeRing</a>

<a id="2770" class="Keyword">module</a> <a id="RingReflection"></a><a id="2777" href="Tactic.RingSolver.html#2777" class="Module">RingReflection</a> <a id="2792" class="Symbol">(</a><a id="2793" href="Tactic.RingSolver.html#2793" class="Bound">`ring</a> <a id="2799" class="Symbol">:</a> <a id="2801" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="2805" class="Symbol">)</a> <a id="2807" class="Keyword">where</a>

  <a id="2816" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2884" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2951" class="Comment">-- the required ring arguments</a>
  <a id="2984" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3032" class="Keyword">infixr</a> <a id="3039" class="Number">6</a> <a id="3041" href="Tactic.RingSolver.html#3048" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3048" href="Tactic.RingSolver.html#3048" class="Function Operator">_$ʳ_</a> <a id="3053" class="Symbol">:</a> <a id="3055" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3060" class="Symbol">→</a> <a id="3062" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="3067" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3072" class="Symbol">→</a> <a id="3074" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3081" href="Tactic.RingSolver.html#3081" class="Bound">nm</a> <a id="3084" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3087" href="Tactic.RingSolver.html#3087" class="Bound">args</a> <a id="3092" class="Symbol">=</a> <a id="3094" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3098" href="Tactic.RingSolver.html#3081" class="Bound">nm</a> <a id="3101" class="Symbol">(</a><a id="3102" class="Number">2</a> <a id="3104" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3109" href="Tactic.RingSolver.html#2793" class="Bound">`ring</a> <a id="3115" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3119" href="Tactic.RingSolver.html#3087" class="Bound">args</a><a id="3123" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3128" href="Tactic.RingSolver.html#3128" class="Function">`Carrier</a> <a id="3137" class="Symbol">:</a> <a id="3139" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3146" href="Tactic.RingSolver.html#3128" class="Function">`Carrier</a> <a id="3155" class="Symbol">=</a> <a id="3157" class="Keyword">quote</a> <a id="3163" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1387" class="Field">Carrier</a> <a id="3171" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3174" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3180" href="Tactic.RingSolver.html#3180" class="Function">`refl</a> <a id="3186" class="Symbol">:</a> <a id="3188" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3195" href="Tactic.RingSolver.html#3180" class="Function">`refl</a> <a id="3201" class="Symbol">=</a> <a id="3203" class="Keyword">quote</a> <a id="3209" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2550" class="Function">refl</a> <a id="3214" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3217" class="Symbol">(</a><a id="3218" class="Number">1</a> <a id="3220" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3225" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3227" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3232" href="Tactic.RingSolver.html#3232" class="Function">`sym</a> <a id="3237" class="Symbol">:</a> <a id="3239" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3244" class="Symbol">→</a> <a id="3246" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3253" href="Tactic.RingSolver.html#3232" class="Function">`sym</a> <a id="3258" href="Tactic.RingSolver.html#3258" class="Bound">x≈y</a> <a id="3262" class="Symbol">=</a> <a id="3264" class="Keyword">quote</a> <a id="3270" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="3274" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3277" class="Symbol">(</a><a id="3278" class="Number">2</a> <a id="3280" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3285" href="Tactic.RingSolver.html#3258" class="Bound">x≈y</a> <a id="3289" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3293" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3295" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3300" href="Tactic.RingSolver.html#3300" class="Function">`trans</a> <a id="3307" class="Symbol">:</a> <a id="3309" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3314" class="Symbol">→</a> <a id="3316" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3321" class="Symbol">→</a> <a id="3323" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3330" href="Tactic.RingSolver.html#3300" class="Function">`trans</a> <a id="3337" href="Tactic.RingSolver.html#3337" class="Bound">x≈y</a> <a id="3341" href="Tactic.RingSolver.html#3341" class="Bound">y≈z</a> <a id="3345" class="Symbol">=</a> <a id="3347" class="Keyword">quote</a> <a id="3353" href="Relation.Binary.Structures.html#1620" class="Function">trans</a> <a id="3359" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3362" class="Symbol">(</a><a id="3363" class="Number">3</a> <a id="3365" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3370" href="Tactic.RingSolver.html#3337" class="Bound">x≈y</a> <a id="3374" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3378" href="Tactic.RingSolver.html#3341" class="Bound">y≈z</a> <a id="3382" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3386" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3388" class="Symbol">)</a>

  <a id="3393" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3459" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3526" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3584" href="Tactic.RingSolver.html#3584" class="Function">getRingOperatorTerms</a> <a id="3605" class="Symbol">:</a> <a id="3607" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="3610" href="Tactic.RingSolver.html#2573" class="Record">RingOperatorTerms</a>
  <a id="3630" href="Tactic.RingSolver.html#3584" class="Function">getRingOperatorTerms</a> <a id="3651" class="Symbol">=</a> <a id="3653" class="Symbol">⦇</a>
    <a id="3659" href="Tactic.RingSolver.html#2617" class="InductiveConstructor Operator">add⇒</a> <a id="3664" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3674" class="Symbol">(</a><a id="3675" class="Keyword">quote</a> <a id="3681" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a>  <a id="3686" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3689" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3691" class="Symbol">)</a>
    <a id="3697" href="Tactic.RingSolver.html#2617" class="InductiveConstructor Operator">mul⇒</a> <a id="3702" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3712" class="Symbol">(</a><a id="3713" class="Keyword">quote</a> <a id="3719" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a>  <a id="3724" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3727" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3729" class="Symbol">)</a>
    <a id="3735" href="Tactic.RingSolver.html#2617" class="InductiveConstructor Operator">pow⇒</a> <a id="3740" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3750" class="Symbol">(</a><a id="3751" class="Keyword">quote</a> <a id="3757" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a>  <a id="3762" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3765" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3767" class="Symbol">)</a>
    <a id="3773" href="Tactic.RingSolver.html#2617" class="InductiveConstructor Operator">neg⇒</a> <a id="3778" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3788" class="Symbol">(</a><a id="3789" class="Keyword">quote</a> <a id="3795" class="Symbol">(</a><a id="3796" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="3798" class="Symbol">)</a> <a id="3800" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3803" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3805" class="Symbol">)</a>
    <a id="3811" href="Tactic.RingSolver.html#2617" class="InductiveConstructor Operator">sub⇒</a> <a id="3816" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3826" class="Symbol">(</a><a id="3827" class="Keyword">quote</a> <a id="3833" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function Operator">_-_</a>  <a id="3838" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="3841" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3843" class="Symbol">)</a>
    <a id="3849" class="Symbol">⦈</a>

<a id="3852" class="Comment">------------------------------------------------------------------------</a>
<a id="3925" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3966" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="3973" href="Tactic.RingSolver.html#3973" class="Module">RingSolverReflection</a> <a id="3994" class="Symbol">(</a><a id="3995" href="Tactic.RingSolver.html#3995" class="Bound">ring</a> <a id="4000" class="Symbol">:</a> <a id="4002" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4006" class="Symbol">)</a> <a id="4008" class="Symbol">(</a><a id="4009" href="Tactic.RingSolver.html#4009" class="Bound">numberOfVariables</a> <a id="4027" class="Symbol">:</a> <a id="4029" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4030" class="Symbol">)</a> <a id="4032" class="Keyword">where</a>
  <a id="4040" class="Keyword">open</a> <a id="4045" href="Tactic.RingSolver.html#2777" class="Module">RingReflection</a> <a id="4060" href="Tactic.RingSolver.html#3995" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4068" href="Tactic.RingSolver.html#4068" class="Function">`numberOfVariables</a> <a id="4087" class="Symbol">:</a> <a id="4089" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4096" href="Tactic.RingSolver.html#4068" class="Function">`numberOfVariables</a> <a id="4115" class="Symbol">=</a> <a id="4117" href="Data.Nat.Reflection.html#644" class="Function">toTerm</a> <a id="4124" href="Tactic.RingSolver.html#4009" class="Bound">numberOfVariables</a>

  <a id="4145" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4215" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4288" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4357" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4426" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4490" class="Keyword">infix</a> <a id="4496" class="Number">-1</a> <a id="4499" href="Tactic.RingSolver.html#4506" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4506" href="Tactic.RingSolver.html#4506" class="Function Operator">_$ᵉ_</a> <a id="4511" class="Symbol">:</a> <a id="4513" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4518" class="Symbol">→</a> <a id="4520" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4525" class="Symbol">(</a><a id="4526" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="4530" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4534" class="Symbol">)</a> <a id="4536" class="Symbol">→</a> <a id="4538" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4545" href="Tactic.RingSolver.html#4545" class="Bound">e</a> <a id="4547" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="4550" href="Tactic.RingSolver.html#4550" class="Bound">xs</a> <a id="4553" class="Symbol">=</a> <a id="4555" href="Agda.Builtin.Reflection.html#4846" class="InductiveConstructor">con</a> <a id="4559" href="Tactic.RingSolver.html#4545" class="Bound">e</a> <a id="4561" class="Symbol">(</a><a id="4562" class="Number">1</a> <a id="4564" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="4569" href="Tactic.RingSolver.html#3128" class="Function">`Carrier</a> <a id="4578" href="Reflection.AST.Argument.html#1751" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4582" href="Tactic.RingSolver.html#4068" class="Function">`numberOfVariables</a> <a id="4601" href="Reflection.AST.Argument.html#1751" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4605" href="Tactic.RingSolver.html#4550" class="Bound">xs</a><a id="4607" class="Symbol">)</a>

  <a id="4612" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4640" href="Tactic.RingSolver.html#4640" class="Function">`Κ</a> <a id="4643" class="Symbol">:</a> <a id="4645" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4650" class="Symbol">→</a> <a id="4652" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4659" href="Tactic.RingSolver.html#4640" class="Function">`Κ</a> <a id="4662" href="Tactic.RingSolver.html#4662" class="Bound">x</a> <a id="4664" class="Symbol">=</a> <a id="4666" class="Keyword">quote</a> <a id="4672" href="Tactic.RingSolver.Core.Expression.html#538" class="InductiveConstructor">Κ</a> <a id="4674" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="4677" class="Symbol">(</a><a id="4678" href="Tactic.RingSolver.html#4662" class="Bound">x</a> <a id="4680" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4684" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4686" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4691" href="Tactic.RingSolver.html#4691" class="Function">`I</a> <a id="4694" class="Symbol">:</a> <a id="4696" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4701" class="Symbol">→</a> <a id="4703" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4710" href="Tactic.RingSolver.html#4691" class="Function">`I</a> <a id="4713" href="Tactic.RingSolver.html#4713" class="Bound">x</a> <a id="4715" class="Symbol">=</a> <a id="4717" class="Keyword">quote</a> <a id="4723" href="Tactic.RingSolver.Core.Expression.html#589" class="InductiveConstructor">Ι</a> <a id="4725" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="4728" class="Symbol">(</a><a id="4729" href="Tactic.RingSolver.html#4713" class="Bound">x</a> <a id="4731" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4735" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4737" class="Symbol">)</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4742" href="Tactic.RingSolver.html#4742" class="Function Operator">_`⊜_</a> <a id="4747" class="Symbol">:</a> <a id="4749" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4754" class="Symbol">→</a> <a id="4756" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4761" class="Symbol">→</a> <a id="4763" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4770" href="Tactic.RingSolver.html#4770" class="Bound">x</a> <a id="4772" href="Tactic.RingSolver.html#4742" class="Function Operator">`⊜</a> <a id="4775" href="Tactic.RingSolver.html#4775" class="Bound">y</a> <a id="4777" class="Symbol">=</a> <a id="4779" class="Keyword">quote</a> <a id="4785" href="Tactic.RingSolver.NonReflective.html#3315" class="Function Operator">_⊜_</a>  <a id="4790" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="4793" class="Symbol">(</a><a id="4794" href="Tactic.RingSolver.html#4068" class="Function">`numberOfVariables</a> <a id="4813" href="Reflection.AST.Argument.html#1751" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4817" href="Tactic.RingSolver.html#4770" class="Bound">x</a> <a id="4819" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4823" href="Tactic.RingSolver.html#4775" class="Bound">y</a> <a id="4825" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4829" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4831" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4836" href="Tactic.RingSolver.html#4836" class="Function">`correct</a> <a id="4845" class="Symbol">:</a> <a id="4847" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4852" class="Symbol">→</a> <a id="4854" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4859" class="Symbol">→</a> <a id="4861" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4868" href="Tactic.RingSolver.html#4836" class="Function">`correct</a> <a id="4877" href="Tactic.RingSolver.html#4877" class="Bound">x</a> <a id="4879" href="Tactic.RingSolver.html#4879" class="Bound">ρ</a> <a id="4881" class="Symbol">=</a> <a id="4883" class="Keyword">quote</a> <a id="4889" href="Tactic.RingSolver.NonReflective.html#2289" class="Function">Ops.correct</a> <a id="4901" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="4904" class="Symbol">(</a><a id="4905" class="Number">1</a> <a id="4907" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="4912" href="Tactic.RingSolver.html#4877" class="Bound">x</a> <a id="4914" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4918" href="Tactic.RingSolver.html#4879" class="Bound">ρ</a> <a id="4920" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4924" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4926" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4931" href="Tactic.RingSolver.html#4931" class="Function">`solver</a> <a id="4939" class="Symbol">:</a> <a id="4941" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4946" class="Symbol">→</a> <a id="4948" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4953" class="Symbol">→</a> <a id="4955" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4962" href="Tactic.RingSolver.html#4931" class="Function">`solver</a> <a id="4970" href="Tactic.RingSolver.html#4970" class="Bound">`f</a> <a id="4973" href="Tactic.RingSolver.html#4973" class="Bound">`eq</a> <a id="4977" class="Symbol">=</a> <a id="4979" class="Keyword">quote</a> <a id="4985" href="Tactic.RingSolver.html#1352" class="Function">solver</a> <a id="4992" href="Tactic.RingSolver.html#3048" class="Function Operator">$ʳ</a> <a id="4995" class="Symbol">(</a><a id="4996" href="Tactic.RingSolver.html#4068" class="Function">`numberOfVariables</a> <a id="5015" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5019" href="Tactic.RingSolver.html#4970" class="Bound">`f</a> <a id="5022" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5026" href="Tactic.RingSolver.html#4973" class="Bound">`eq</a> <a id="5030" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5034" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5036" class="Symbol">)</a>

  <a id="5041" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5108" class="Comment">-- used internally by the solver.</a>
  <a id="5144" class="Comment">--</a>
  <a id="5149" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5215" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5278" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5344" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5412" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5479" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5541" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5582" class="Comment">--</a>
  <a id="5587" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5656" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5724" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5781" href="Tactic.RingSolver.html#5781" class="Function">convertTerm</a> <a id="5793" class="Symbol">:</a> <a id="5795" href="Tactic.RingSolver.html#2573" class="Record">RingOperatorTerms</a> <a id="5813" class="Symbol">→</a> <a id="5815" href="Tactic.RingSolver.html#1595" class="Function">VarMap</a> <a id="5822" class="Symbol">→</a> <a id="5824" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5829" class="Symbol">→</a> <a id="5831" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5834" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="5841" href="Tactic.RingSolver.html#5781" class="Function">convertTerm</a> <a id="5853" href="Tactic.RingSolver.html#5853" class="Bound">operatorTerms</a> <a id="5867" href="Tactic.RingSolver.html#5867" class="Bound">varMap</a> <a id="5874" class="Symbol">=</a> <a id="5876" href="Tactic.RingSolver.html#5953" class="Function">convert</a>
    <a id="5888" class="Keyword">where</a>
    <a id="5898" class="Keyword">open</a> <a id="5903" href="Tactic.RingSolver.html#2573" class="Module">RingOperatorTerms</a> <a id="5921" href="Tactic.RingSolver.html#5853" class="Bound">operatorTerms</a>

    <a id="5940" class="Keyword">mutual</a>
      <a id="5953" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="5961" class="Symbol">:</a> <a id="5963" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5968" class="Symbol">→</a> <a id="5970" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5973" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="5984" class="Comment">-- First try and match directly against the fields</a>
      <a id="6041" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6049" class="Symbol">(</a><a id="6050" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6054" class="Symbol">(</a><a id="6055" class="Keyword">quote</a> <a id="6061" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a><a id="6064" class="Symbol">)</a> <a id="6066" href="Tactic.RingSolver.html#6066" class="Bound">xs</a><a id="6068" class="Symbol">)</a> <a id="6070" class="Symbol">=</a> <a id="6072" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="6083" class="Symbol">(</a><a id="6084" class="Keyword">quote</a> <a id="6090" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="6093" class="Symbol">)</a> <a id="6095" href="Tactic.RingSolver.html#6066" class="Bound">xs</a>
      <a id="6104" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6112" class="Symbol">(</a><a id="6113" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6117" class="Symbol">(</a><a id="6118" class="Keyword">quote</a> <a id="6124" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a><a id="6127" class="Symbol">)</a> <a id="6129" href="Tactic.RingSolver.html#6129" class="Bound">xs</a><a id="6131" class="Symbol">)</a> <a id="6133" class="Symbol">=</a> <a id="6135" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="6146" class="Symbol">(</a><a id="6147" class="Keyword">quote</a> <a id="6153" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="6156" class="Symbol">)</a> <a id="6158" href="Tactic.RingSolver.html#6129" class="Bound">xs</a>
      <a id="6167" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6175" class="Symbol">(</a><a id="6176" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6180" class="Symbol">(</a><a id="6181" class="Keyword">quote</a>  <a id="6188" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="6190" class="Symbol">)</a> <a id="6192" href="Tactic.RingSolver.html#6192" class="Bound">xs</a><a id="6194" class="Symbol">)</a> <a id="6196" class="Symbol">=</a> <a id="6198" href="Tactic.RingSolver.html#7331" class="Function">convertOp₁</a> <a id="6209" class="Symbol">(</a><a id="6210" class="Keyword">quote</a>  <a id="6217" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="6219" class="Symbol">)</a> <a id="6221" href="Tactic.RingSolver.html#6192" class="Bound">xs</a>
      <a id="6230" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6238" class="Symbol">(</a><a id="6239" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6243" class="Symbol">(</a><a id="6244" class="Keyword">quote</a> <a id="6250" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a><a id="6253" class="Symbol">)</a> <a id="6255" href="Tactic.RingSolver.html#6255" class="Bound">xs</a><a id="6257" class="Symbol">)</a> <a id="6259" class="Symbol">=</a> <a id="6261" href="Tactic.RingSolver.html#7570" class="Function">convertExp</a> <a id="6272" href="Tactic.RingSolver.html#6255" class="Bound">xs</a>
      <a id="6281" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6289" class="Symbol">(</a><a id="6290" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6294" class="Symbol">(</a><a id="6295" class="Keyword">quote</a> <a id="6301" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function Operator">_-_</a><a id="6304" class="Symbol">)</a> <a id="6306" href="Tactic.RingSolver.html#6306" class="Bound">xs</a><a id="6308" class="Symbol">)</a> <a id="6310" class="Symbol">=</a> <a id="6312" href="Tactic.RingSolver.html#7821" class="Function">convertSub</a> <a id="6323" href="Tactic.RingSolver.html#6306" class="Bound">xs</a>
      <a id="6332" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6410" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6418" class="Symbol">(</a><a id="6419" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6423" href="Tactic.RingSolver.html#6423" class="Bound">nm</a>          <a id="6435" href="Tactic.RingSolver.html#6435" class="Bound">xs</a><a id="6437" class="Symbol">)</a> <a id="6439" class="Symbol">=</a> <a id="6441" href="Tactic.RingSolver.html#8122" class="Function">convertUnknownName</a> <a id="6460" href="Tactic.RingSolver.html#6423" class="Bound">nm</a> <a id="6463" href="Tactic.RingSolver.html#6435" class="Bound">xs</a>
      <a id="6472" class="Comment">-- Variables</a>
      <a id="6491" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6499" href="Tactic.RingSolver.html#6499" class="Bound">v</a><a id="6500" class="Symbol">@(</a><a id="6502" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="6506" href="Tactic.RingSolver.html#6506" class="Bound">x</a> <a id="6508" class="Symbol">_)</a>          <a id="6520" class="Symbol">=</a> <a id="6522" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="6529" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6531" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a> <a id="6541" class="Symbol">(</a><a id="6542" href="Tactic.RingSolver.html#4640" class="Function">`Κ</a> <a id="6545" href="Tactic.RingSolver.html#6499" class="Bound">v</a><a id="6546" class="Symbol">)</a> <a id="6548" class="Symbol">(</a><a id="6549" href="Tactic.RingSolver.html#5867" class="Bound">varMap</a> <a id="6556" href="Tactic.RingSolver.html#6506" class="Bound">x</a><a id="6557" class="Symbol">)</a>
      <a id="6565" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6619" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="6627" class="Symbol">(</a><a id="6628" href="Data.Nat.Reflection.html#607" class="InductiveConstructor">`suc</a> <a id="6633" href="Tactic.RingSolver.html#6633" class="Bound">x</a><a id="6634" class="Symbol">)</a>             <a id="6648" class="Symbol">=</a> <a id="6650" href="Tactic.RingSolver.html#8645" class="Function">convertSuc</a> <a id="6661" href="Tactic.RingSolver.html#6633" class="Bound">x</a>
      <a id="6669" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6727" href="Tactic.RingSolver.html#5953" class="CatchallClause Function">convert</a><a id="6734" class="CatchallClause"> </a><a id="6735" href="Tactic.RingSolver.html#6735" class="CatchallClause Bound">t</a>                    <a id="6756" class="Symbol">=</a> <a id="6758" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="6765" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6767" href="Tactic.RingSolver.html#4640" class="Function">`Κ</a> <a id="6770" href="Tactic.RingSolver.html#6735" class="Bound">t</a>

      <a id="6779" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6848" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6918" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="6987" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7044" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="7055" class="Symbol">:</a> <a id="7057" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7062" class="Symbol">→</a> <a id="7064" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7069" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7074" class="Symbol">→</a> <a id="7076" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7079" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7090" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="7101" href="Tactic.RingSolver.html#7101" class="Bound">nm</a> <a id="7104" class="Symbol">(</a><a id="7105" href="Tactic.RingSolver.html#7105" class="Bound">x</a> <a id="7107" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7111" href="Tactic.RingSolver.html#7111" class="Bound">y</a> <a id="7113" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7117" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7119" class="Symbol">)</a> <a id="7121" class="Symbol">=</a> <a id="7123" class="Keyword">do</a>
        <a id="7134" href="Tactic.RingSolver.html#7134" class="Bound">x&#39;</a> <a id="7137" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7139" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="7147" href="Tactic.RingSolver.html#7105" class="Bound">x</a>
        <a id="7157" href="Tactic.RingSolver.html#7157" class="Bound">y&#39;</a> <a id="7160" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7162" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="7170" href="Tactic.RingSolver.html#7111" class="Bound">y</a>
        <a id="7180" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7187" class="Symbol">(</a><a id="7188" href="Tactic.RingSolver.html#7101" class="Bound">nm</a> <a id="7191" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="7194" class="Symbol">(</a><a id="7195" href="Tactic.RingSolver.html#7134" class="Bound">x&#39;</a> <a id="7198" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7202" href="Tactic.RingSolver.html#7157" class="Bound">y&#39;</a> <a id="7205" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7209" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7211" class="Symbol">))</a>
      <a id="7220" href="Tactic.RingSolver.html#7044" class="CatchallClause Function">convertOp₂</a><a id="7230" class="CatchallClause"> </a><a id="7231" href="Tactic.RingSolver.html#7231" class="CatchallClause Bound">nm</a><a id="7233" class="CatchallClause"> </a><a id="7234" class="CatchallClause Symbol">(</a><a id="7235" href="Tactic.RingSolver.html#7235" class="CatchallClause Bound">x</a><a id="7236" class="CatchallClause"> </a><a id="7237" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7238" class="CatchallClause"> </a><a id="7239" href="Tactic.RingSolver.html#7239" class="CatchallClause Bound">xs</a><a id="7241" class="CatchallClause Symbol">)</a>         <a id="7251" class="Symbol">=</a> <a id="7253" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="7264" href="Tactic.RingSolver.html#7231" class="Bound">nm</a> <a id="7267" href="Tactic.RingSolver.html#7239" class="Bound">xs</a>
      <a id="7276" href="Tactic.RingSolver.html#7044" class="CatchallClause Function">convertOp₂</a><a id="7286" class="CatchallClause"> </a><a id="7287" class="CatchallClause Symbol">_</a><a id="7288" class="CatchallClause">  </a><a id="7290" class="CatchallClause Symbol">_</a>                <a id="7307" class="Symbol">=</a> <a id="7309" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7316" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7331" href="Tactic.RingSolver.html#7331" class="Function">convertOp₁</a> <a id="7342" class="Symbol">:</a> <a id="7344" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7349" class="Symbol">→</a> <a id="7351" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7356" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7361" class="Symbol">→</a> <a id="7363" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7366" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7377" href="Tactic.RingSolver.html#7331" class="Function">convertOp₁</a> <a id="7388" href="Tactic.RingSolver.html#7388" class="Bound">nm</a> <a id="7391" class="Symbol">(</a><a id="7392" href="Tactic.RingSolver.html#7392" class="Bound">x</a> <a id="7394" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7398" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7400" class="Symbol">)</a> <a id="7402" class="Symbol">=</a> <a id="7404" class="Keyword">do</a>
        <a id="7415" href="Tactic.RingSolver.html#7415" class="Bound">x&#39;</a> <a id="7418" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7420" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="7428" href="Tactic.RingSolver.html#7392" class="Bound">x</a>
        <a id="7438" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7445" class="Symbol">(</a><a id="7446" href="Tactic.RingSolver.html#7388" class="Bound">nm</a> <a id="7449" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="7452" class="Symbol">(</a><a id="7453" href="Tactic.RingSolver.html#7415" class="Bound">x&#39;</a> <a id="7456" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7460" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7462" class="Symbol">))</a>
      <a id="7471" href="Tactic.RingSolver.html#7331" class="CatchallClause Function">convertOp₁</a><a id="7481" class="CatchallClause"> </a><a id="7482" href="Tactic.RingSolver.html#7482" class="CatchallClause Bound">nm</a><a id="7484" class="CatchallClause"> </a><a id="7485" class="CatchallClause Symbol">(</a><a id="7486" href="Tactic.RingSolver.html#7486" class="CatchallClause Bound">x</a><a id="7487" class="CatchallClause"> </a><a id="7488" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7489" class="CatchallClause"> </a><a id="7490" href="Tactic.RingSolver.html#7490" class="CatchallClause Bound">xs</a><a id="7492" class="CatchallClause Symbol">)</a>   <a id="7496" class="Symbol">=</a> <a id="7498" href="Tactic.RingSolver.html#7331" class="Function">convertOp₁</a> <a id="7509" href="Tactic.RingSolver.html#7482" class="Bound">nm</a> <a id="7512" href="Tactic.RingSolver.html#7490" class="Bound">xs</a>
      <a id="7521" href="Tactic.RingSolver.html#7331" class="CatchallClause Function">convertOp₁</a><a id="7531" class="CatchallClause"> </a><a id="7532" class="CatchallClause Symbol">_</a><a id="7533" class="CatchallClause">  </a><a id="7535" class="CatchallClause Symbol">_</a>          <a id="7546" class="Symbol">=</a> <a id="7548" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7555" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7570" href="Tactic.RingSolver.html#7570" class="Function">convertExp</a> <a id="7581" class="Symbol">:</a> <a id="7583" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7588" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7593" class="Symbol">→</a> <a id="7595" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7598" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7609" href="Tactic.RingSolver.html#7570" class="Function">convertExp</a> <a id="7620" class="Symbol">(</a><a id="7621" href="Tactic.RingSolver.html#7621" class="Bound">x</a> <a id="7623" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7627" href="Tactic.RingSolver.html#7627" class="Bound">y</a> <a id="7629" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7633" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7635" class="Symbol">)</a> <a id="7637" class="Symbol">=</a> <a id="7639" class="Keyword">do</a>
        <a id="7650" href="Tactic.RingSolver.html#7650" class="Bound">x&#39;</a> <a id="7653" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7655" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="7663" href="Tactic.RingSolver.html#7621" class="Bound">x</a>
        <a id="7673" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7680" class="Symbol">(</a><a id="7681" class="Keyword">quote</a> <a id="7687" href="Tactic.RingSolver.Core.Expression.html#748" class="InductiveConstructor Operator">_⊛_</a> <a id="7691" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="7694" class="Symbol">(</a><a id="7695" href="Tactic.RingSolver.html#7650" class="Bound">x&#39;</a> <a id="7698" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7702" href="Tactic.RingSolver.html#7627" class="Bound">y</a> <a id="7704" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7708" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7710" class="Symbol">))</a>
      <a id="7719" href="Tactic.RingSolver.html#7570" class="CatchallClause Function">convertExp</a><a id="7729" class="CatchallClause"> </a><a id="7730" class="CatchallClause Symbol">(</a><a id="7731" href="Tactic.RingSolver.html#7731" class="CatchallClause Bound">x</a><a id="7732" class="CatchallClause"> </a><a id="7733" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7734" class="CatchallClause"> </a><a id="7735" href="Tactic.RingSolver.html#7735" class="CatchallClause Bound">xs</a><a id="7737" class="CatchallClause Symbol">)</a>         <a id="7747" class="Symbol">=</a> <a id="7749" href="Tactic.RingSolver.html#7570" class="Function">convertExp</a> <a id="7760" href="Tactic.RingSolver.html#7735" class="Bound">xs</a>
      <a id="7769" href="Tactic.RingSolver.html#7570" class="CatchallClause Function">convertExp</a><a id="7779" class="CatchallClause"> </a><a id="7780" class="CatchallClause Symbol">_</a>                <a id="7797" class="Symbol">=</a> <a id="7799" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7806" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7821" href="Tactic.RingSolver.html#7821" class="Function">convertSub</a> <a id="7832" class="Symbol">:</a> <a id="7834" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7839" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7844" class="Symbol">→</a> <a id="7846" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7849" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7860" href="Tactic.RingSolver.html#7821" class="Function">convertSub</a> <a id="7871" class="Symbol">(</a><a id="7872" href="Tactic.RingSolver.html#7872" class="Bound">x</a> <a id="7874" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7878" href="Tactic.RingSolver.html#7878" class="Bound">y</a> <a id="7880" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7884" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7886" class="Symbol">)</a> <a id="7888" class="Symbol">=</a> <a id="7890" class="Keyword">do</a>
        <a id="7901" href="Tactic.RingSolver.html#7901" class="Bound">x&#39;</a>  <a id="7905" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7907" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="7915" href="Tactic.RingSolver.html#7872" class="Bound">x</a>
        <a id="7925" href="Tactic.RingSolver.html#7925" class="Bound">-y&#39;</a> <a id="7929" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7931" href="Tactic.RingSolver.html#7331" class="Function">convertOp₁</a> <a id="7942" class="Symbol">(</a><a id="7943" class="Keyword">quote</a> <a id="7949" class="Symbol">(</a><a id="7950" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="7952" class="Symbol">))</a> <a id="7955" class="Symbol">(</a><a id="7956" href="Tactic.RingSolver.html#7878" class="Bound">y</a> <a id="7958" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7962" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7964" class="Symbol">)</a>
        <a id="7974" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7981" class="Symbol">(</a><a id="7982" class="Keyword">quote</a> <a id="7988" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="7992" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="7995" href="Tactic.RingSolver.html#7901" class="Bound">x&#39;</a> <a id="7998" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8002" href="Tactic.RingSolver.html#7925" class="Bound">-y&#39;</a> <a id="8006" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8010" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8012" class="Symbol">)</a>
      <a id="8020" href="Tactic.RingSolver.html#7821" class="CatchallClause Function">convertSub</a><a id="8030" class="CatchallClause"> </a><a id="8031" class="CatchallClause Symbol">(</a><a id="8032" href="Tactic.RingSolver.html#8032" class="CatchallClause Bound">x</a><a id="8033" class="CatchallClause"> </a><a id="8034" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8035" class="CatchallClause"> </a><a id="8036" href="Tactic.RingSolver.html#8036" class="CatchallClause Bound">xs</a><a id="8038" class="CatchallClause Symbol">)</a>         <a id="8048" class="Symbol">=</a> <a id="8050" href="Tactic.RingSolver.html#7821" class="Function">convertSub</a> <a id="8061" href="Tactic.RingSolver.html#8036" class="Bound">xs</a>
      <a id="8070" href="Tactic.RingSolver.html#7821" class="CatchallClause Function">convertSub</a><a id="8080" class="CatchallClause"> </a><a id="8081" class="CatchallClause Symbol">_</a>                <a id="8098" class="Symbol">=</a> <a id="8100" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="8107" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="8122" href="Tactic.RingSolver.html#8122" class="Function">convertUnknownName</a> <a id="8141" class="Symbol">:</a> <a id="8143" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="8148" class="Symbol">→</a> <a id="8150" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="8155" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8160" class="Symbol">→</a> <a id="8162" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8165" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8176" href="Tactic.RingSolver.html#8122" class="Function">convertUnknownName</a> <a id="8195" href="Tactic.RingSolver.html#8195" class="Bound">nm</a> <a id="8198" href="Tactic.RingSolver.html#8198" class="Bound">xs</a> <a id="8201" class="Symbol">=</a> <a id="8203" class="Keyword">do</a>
        <a id="8214" href="Tactic.RingSolver.html#8214" class="Bound">nameTerm</a> <a id="8223" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="8225" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="8235" class="Symbol">(</a><a id="8236" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8240" href="Tactic.RingSolver.html#8195" class="Bound">nm</a> <a id="8243" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8245" class="Symbol">)</a>
        <a id="8255" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8258" class="Symbol">(</a><a id="8259" href="Tactic.RingSolver.html#8214" class="Bound">nameTerm</a> <a id="8268" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8272" href="Tactic.RingSolver.html#2655" class="Function">add</a><a id="8275" class="Symbol">)</a> <a id="8277" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8282" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="8293" class="Symbol">(</a><a id="8294" class="Keyword">quote</a> <a id="8300" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="8303" class="Symbol">)</a> <a id="8305" href="Tactic.RingSolver.html#8198" class="Bound">xs</a> <a id="8308" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
          <a id="8323" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8326" class="Symbol">(</a><a id="8327" href="Tactic.RingSolver.html#8214" class="Bound">nameTerm</a> <a id="8336" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8340" href="Tactic.RingSolver.html#2659" class="Function">mul</a><a id="8343" class="Symbol">)</a> <a id="8345" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8350" href="Tactic.RingSolver.html#7044" class="Function">convertOp₂</a> <a id="8361" class="Symbol">(</a><a id="8362" class="Keyword">quote</a> <a id="8368" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="8371" class="Symbol">)</a> <a id="8373" href="Tactic.RingSolver.html#8198" class="Bound">xs</a> <a id="8376" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
            <a id="8393" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8396" class="Symbol">(</a><a id="8397" href="Tactic.RingSolver.html#8214" class="Bound">nameTerm</a> <a id="8406" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8410" href="Tactic.RingSolver.html#2667" class="Function">neg</a><a id="8413" class="Symbol">)</a> <a id="8415" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8420" href="Tactic.RingSolver.html#7331" class="Function">convertOp₁</a> <a id="8431" class="Symbol">(</a><a id="8432" class="Keyword">quote</a> <a id="8438" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="8440" class="Symbol">)</a>  <a id="8443" href="Tactic.RingSolver.html#8198" class="Bound">xs</a> <a id="8446" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
              <a id="8465" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8468" class="Symbol">(</a><a id="8469" href="Tactic.RingSolver.html#8214" class="Bound">nameTerm</a> <a id="8478" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8482" href="Tactic.RingSolver.html#2663" class="Function">pow</a><a id="8485" class="Symbol">)</a> <a id="8487" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8492" href="Tactic.RingSolver.html#7570" class="Function">convertExp</a>             <a id="8515" href="Tactic.RingSolver.html#8198" class="Bound">xs</a> <a id="8518" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                <a id="8539" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8542" class="Symbol">(</a><a id="8543" href="Tactic.RingSolver.html#8214" class="Bound">nameTerm</a> <a id="8552" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8556" href="Tactic.RingSolver.html#2671" class="Function">sub</a><a id="8559" class="Symbol">)</a> <a id="8561" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8566" href="Tactic.RingSolver.html#7821" class="Function">convertSub</a>            <a id="8588" href="Tactic.RingSolver.html#8198" class="Bound">xs</a> <a id="8591" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                  <a id="8614" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="8621" class="Symbol">(</a><a id="8622" href="Tactic.RingSolver.html#4640" class="Function">`Κ</a> <a id="8625" class="Symbol">(</a><a id="8626" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8630" href="Tactic.RingSolver.html#8195" class="Bound">nm</a> <a id="8633" href="Tactic.RingSolver.html#8198" class="Bound">xs</a><a id="8635" class="Symbol">))</a>

      <a id="8645" href="Tactic.RingSolver.html#8645" class="Function">convertSuc</a> <a id="8656" class="Symbol">:</a> <a id="8658" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8663" class="Symbol">→</a> <a id="8665" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8668" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8679" href="Tactic.RingSolver.html#8645" class="Function">convertSuc</a> <a id="8690" href="Tactic.RingSolver.html#8690" class="Bound">x</a> <a id="8692" class="Symbol">=</a> <a id="8694" class="Keyword">do</a> <a id="8697" href="Tactic.RingSolver.html#8697" class="Bound">x&#39;</a> <a id="8700" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="8702" href="Tactic.RingSolver.html#5953" class="Function">convert</a> <a id="8710" href="Tactic.RingSolver.html#8690" class="Bound">x</a><a id="8711" class="Symbol">;</a> <a id="8713" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="8720" class="Symbol">(</a><a id="8721" class="Keyword">quote</a> <a id="8727" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="8731" href="Tactic.RingSolver.html#4506" class="Function Operator">$ᵉ</a> <a id="8734" class="Symbol">(</a><a id="8735" href="Tactic.RingSolver.html#4640" class="Function">`Κ</a> <a id="8738" class="Symbol">(</a><a id="8739" href="Data.Nat.Reflection.html#644" class="Function">toTerm</a> <a id="8746" class="Number">1</a><a id="8747" class="Symbol">)</a> <a id="8749" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8753" href="Tactic.RingSolver.html#8697" class="Bound">x&#39;</a> <a id="8756" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8760" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8762" class="Symbol">))</a>

<a id="8766" class="Comment">------------------------------------------------------------------------</a>
<a id="8839" class="Comment">-- Macros</a>
<a id="8849" class="Comment">------------------------------------------------------------------------</a>
<a id="8922" class="Comment">-- Quantified macro</a>

<a id="8943" class="Keyword">open</a> <a id="8948" href="Tactic.RingSolver.html#2777" class="Module">RingReflection</a>
<a id="8963" class="Keyword">open</a> <a id="8968" href="Tactic.RingSolver.html#3973" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="8990" href="Tactic.RingSolver.html#8990" class="Function">malformedForallTypeError</a> <a id="9015" class="Symbol">:</a> <a id="9017" class="Symbol">∀</a> <a id="9019" class="Symbol">{</a><a id="9020" href="Tactic.RingSolver.html#9020" class="Bound">a</a><a id="9021" class="Symbol">}</a> <a id="9023" class="Symbol">{</a><a id="9024" href="Tactic.RingSolver.html#9024" class="Bound">A</a> <a id="9026" class="Symbol">:</a> <a id="9028" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="9032" href="Tactic.RingSolver.html#9020" class="Bound">a</a><a id="9033" class="Symbol">}</a> <a id="9035" class="Symbol">→</a> <a id="9037" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9042" class="Symbol">→</a> <a id="9044" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9047" href="Tactic.RingSolver.html#9024" class="Bound">A</a>
<a id="9049" href="Tactic.RingSolver.html#8990" class="Function">malformedForallTypeError</a> <a id="9074" href="Tactic.RingSolver.html#9074" class="Bound">found</a> <a id="9080" class="Symbol">=</a> <a id="9082" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="9094" class="Symbol">(</a> <a id="9096" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9103" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9132" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9134" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9141" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9201" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9203" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9210" class="String">&quot;Instead: &quot;</a>
  <a id="9224" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9226" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9234" href="Tactic.RingSolver.html#9074" class="Bound">found</a>
  <a id="9242" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9244" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9246" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9249" href="Tactic.RingSolver.html#9249" class="Function">quantifiedVarMap</a> <a id="9266" class="Symbol">:</a> <a id="9268" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9270" class="Symbol">→</a> <a id="9272" href="Tactic.RingSolver.html#1595" class="Function">VarMap</a>
<a id="9279" href="Tactic.RingSolver.html#9249" class="Function">quantifiedVarMap</a> <a id="9296" href="Tactic.RingSolver.html#9296" class="Bound">numVars</a> <a id="9304" href="Tactic.RingSolver.html#9304" class="Bound">i</a> <a id="9306" class="Symbol">=</a>
  <a id="9310" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="9313" href="Tactic.RingSolver.html#9304" class="Bound">i</a> <a id="9315" href="Data.Nat.Base.html#1230" class="Primitive Operator">&lt;ᵇ</a> <a id="9318" href="Tactic.RingSolver.html#9296" class="Bound">numVars</a>
    <a id="9330" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="9335" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="9340" class="Symbol">(</a><a id="9341" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="9345" href="Tactic.RingSolver.html#9304" class="Bound">i</a> <a id="9347" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9349" class="Symbol">)</a>
    <a id="9355" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="9360" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9369" href="Tactic.RingSolver.html#9369" class="Function">constructCallToSolver</a> <a id="9391" class="Symbol">:</a> <a id="9393" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9398" class="Symbol">→</a> <a id="9400" href="Tactic.RingSolver.html#2573" class="Record">RingOperatorTerms</a> <a id="9418" class="Symbol">→</a> <a id="9420" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="9425" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="9432" class="Symbol">→</a> <a id="9434" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9439" class="Symbol">→</a> <a id="9441" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9446" class="Symbol">→</a> <a id="9448" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9451" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="9456" href="Tactic.RingSolver.html#9369" class="Function">constructCallToSolver</a> <a id="9478" href="Tactic.RingSolver.html#9478" class="Bound">`ring</a> <a id="9484" href="Tactic.RingSolver.html#9484" class="Bound">opNames</a> <a id="9492" href="Tactic.RingSolver.html#9492" class="Bound">variables</a> <a id="9502" href="Tactic.RingSolver.html#9502" class="Bound">`lhs</a> <a id="9507" href="Tactic.RingSolver.html#9507" class="Bound">`rhs</a> <a id="9512" class="Symbol">=</a> <a id="9514" class="Keyword">do</a>
  <a id="9519" href="Tactic.RingSolver.html#9519" class="Bound">`lhsExpr</a> <a id="9528" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="9530" href="Tactic.RingSolver.html#9799" class="Function">conv</a> <a id="9535" href="Tactic.RingSolver.html#9502" class="Bound">`lhs</a>
  <a id="9542" href="Tactic.RingSolver.html#9542" class="Bound">`rhsExpr</a> <a id="9551" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="9553" href="Tactic.RingSolver.html#9799" class="Function">conv</a> <a id="9558" href="Tactic.RingSolver.html#9507" class="Bound">`rhs</a>

  <a id="9566" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="9573" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="9575" href="Tactic.RingSolver.html#4931" class="Function">`solver</a> <a id="9583" href="Tactic.RingSolver.html#9478" class="Bound">`ring</a> <a id="9589" href="Tactic.RingSolver.html#9750" class="Function">numVars</a>
                    <a id="9617" class="Symbol">(</a><a id="9618" href="Reflection.AST.Term.html#3494" class="Function">prependVLams</a> <a id="9631" href="Tactic.RingSolver.html#9492" class="Bound">variables</a> <a id="9641" class="Symbol">(</a><a id="9642" href="Tactic.RingSolver.html#4742" class="Function Operator">_`⊜_</a> <a id="9647" href="Tactic.RingSolver.html#9478" class="Bound">`ring</a> <a id="9653" href="Tactic.RingSolver.html#9750" class="Function">numVars</a> <a id="9661" href="Tactic.RingSolver.html#9519" class="Bound">`lhsExpr</a> <a id="9670" href="Tactic.RingSolver.html#9542" class="Bound">`rhsExpr</a><a id="9678" class="Symbol">))</a>
                    <a id="9701" class="Symbol">(</a><a id="9702" href="Reflection.AST.Term.html#3396" class="Function">prependHLams</a> <a id="9715" href="Tactic.RingSolver.html#9492" class="Bound">variables</a> <a id="9725" class="Symbol">(</a><a id="9726" href="Tactic.RingSolver.html#3180" class="Function">`refl</a> <a id="9732" href="Tactic.RingSolver.html#9478" class="Bound">`ring</a><a id="9737" class="Symbol">))</a>
  <a id="9742" class="Keyword">where</a>
  <a id="9750" href="Tactic.RingSolver.html#9750" class="Function">numVars</a> <a id="9758" class="Symbol">:</a> <a id="9760" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
  <a id="9764" href="Tactic.RingSolver.html#9750" class="Function">numVars</a> <a id="9772" class="Symbol">=</a> <a id="9774" href="Data.List.Base.html#4864" class="Function">List.length</a> <a id="9786" href="Tactic.RingSolver.html#9492" class="Bound">variables</a>

  <a id="9799" href="Tactic.RingSolver.html#9799" class="Function">conv</a> <a id="9804" class="Symbol">:</a> <a id="9806" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9811" class="Symbol">→</a> <a id="9813" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9816" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="9823" href="Tactic.RingSolver.html#9799" class="Function">conv</a> <a id="9828" class="Symbol">=</a> <a id="9830" href="Tactic.RingSolver.html#5781" class="Function">convertTerm</a> <a id="9842" href="Tactic.RingSolver.html#9478" class="Bound">`ring</a> <a id="9848" href="Tactic.RingSolver.html#9750" class="Function">numVars</a> <a id="9856" href="Tactic.RingSolver.html#9484" class="Bound">opNames</a> <a id="9864" class="Symbol">(</a><a id="9865" href="Tactic.RingSolver.html#9249" class="Function">quantifiedVarMap</a> <a id="9882" href="Tactic.RingSolver.html#9750" class="Function">numVars</a><a id="9889" class="Symbol">)</a>

<a id="9892" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9958" class="Comment">-- variables are universally quantified over:</a>
<a id="10004" class="Comment">--</a>
<a id="10007" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10042" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10068" class="Comment">--</a>
<a id="10071" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10134" class="Comment">-- (Find some example implementations in</a>
<a id="10175" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10235" href="Tactic.RingSolver.html#10235" class="Function">solve-∀-macro</a> <a id="10249" class="Symbol">:</a> <a id="10251" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10256" class="Symbol">→</a> <a id="10258" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10263" class="Symbol">→</a> <a id="10265" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10268" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="10270" href="Tactic.RingSolver.html#10235" class="Function">solve-∀-macro</a> <a id="10284" href="Tactic.RingSolver.html#10284" class="Bound">ring</a> <a id="10289" href="Tactic.RingSolver.html#10289" class="Bound">hole</a> <a id="10294" class="Symbol">=</a> <a id="10296" class="Keyword">do</a>
  <a id="10301" href="Tactic.RingSolver.html#10301" class="Bound">`ring</a> <a id="10307" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10309" href="Tactic.RingSolver.html#2683" class="Function">checkIsRing</a> <a id="10321" class="Symbol">(</a><a id="10322" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="10326" href="Tactic.RingSolver.html#10284" class="Bound">ring</a> <a id="10331" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10333" class="Symbol">)</a>
  <a id="10337" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="10348" href="Tactic.RingSolver.html#10348" class="Bound">operatorTerms</a> <a id="10362" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10364" href="Tactic.RingSolver.html#3584" class="Function">getRingOperatorTerms</a> <a id="10385" href="Tactic.RingSolver.html#10301" class="Bound">`ring</a>

  <a id="10394" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10433" href="Tactic.RingSolver.html#10433" class="Bound">`hole</a> <a id="10439" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10441" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="10451" href="Tactic.RingSolver.html#10289" class="Bound">hole</a> <a id="10456" href="Reflection.TCM.Syntax.html#667" class="Function Operator">&gt;&gt;=</a> <a id="10460" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="10469" class="Keyword">let</a> <a id="10473" href="Tactic.RingSolver.html#10473" class="Bound">variablesAndTypes</a> <a id="10491" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10493" href="Tactic.RingSolver.html#10493" class="Bound">equation</a> <a id="10502" class="Symbol">=</a> <a id="10504" href="Reflection.AST.Term.html#3125" class="Function">stripPis</a> <a id="10513" href="Tactic.RingSolver.html#10433" class="Bound">`hole</a>

  <a id="10522" class="Keyword">let</a> <a id="10526" href="Tactic.RingSolver.html#10526" class="Bound">variables</a> <a id="10536" class="Symbol">=</a> <a id="10538" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="10547" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="10553" href="Tactic.RingSolver.html#10473" class="Bound">variablesAndTypes</a>
  <a id="10573" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10578" class="Symbol">(</a><a id="10579" href="Tactic.RingSolver.html#10579" class="Bound">lhs</a> <a id="10583" href="Data.Vec.Base.html#1091" class="InductiveConstructor Operator">∷</a> <a id="10585" href="Tactic.RingSolver.html#10585" class="Bound">rhs</a> <a id="10589" href="Data.Vec.Base.html#1091" class="InductiveConstructor Operator">∷</a> <a id="10591" href="Data.Vec.Base.html#1072" class="InductiveConstructor">[]</a><a id="10593" class="Symbol">)</a> <a id="10595" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10597" href="Reflection.TCM.Syntax.html#508" class="Function">pure</a> <a id="10602" class="Symbol">(</a><a id="10603" href="Tactic.RingSolver.html#1778" class="Function">getVisibleArgs</a> <a id="10618" class="Number">2</a> <a id="10620" href="Tactic.RingSolver.html#10493" class="Bound">equation</a><a id="10628" class="Symbol">)</a>
    <a id="10634" class="Keyword">where</a> <a id="10640" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="10648" class="Symbol">→</a> <a id="10650" href="Tactic.RingSolver.html#8990" class="Function">malformedForallTypeError</a> <a id="10675" href="Tactic.RingSolver.html#10433" class="Bound">`hole</a>

  <a id="10684" href="Tactic.RingSolver.html#10684" class="Bound">solverCall</a> <a id="10695" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10697" href="Tactic.RingSolver.html#9369" class="Function">constructCallToSolver</a> <a id="10719" href="Tactic.RingSolver.html#10301" class="Bound">`ring</a> <a id="10725" href="Tactic.RingSolver.html#10348" class="Bound">operatorTerms</a> <a id="10739" href="Tactic.RingSolver.html#10526" class="Bound">variables</a> <a id="10749" href="Tactic.RingSolver.html#10579" class="Bound">lhs</a> <a id="10753" href="Tactic.RingSolver.html#10585" class="Bound">rhs</a>
  <a id="10759" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="10765" href="Tactic.RingSolver.html#10289" class="Bound">hole</a> <a id="10770" href="Tactic.RingSolver.html#10684" class="Bound">solverCall</a>

<a id="10782" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10790" href="Tactic.RingSolver.html#10790" class="Function">solve-∀</a> <a id="10798" class="Symbol">:</a> <a id="10800" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10805" class="Symbol">→</a> <a id="10807" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10812" class="Symbol">→</a> <a id="10814" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10817" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="10821" href="Tactic.RingSolver.html#10790" class="Function">solve-∀</a> <a id="10829" class="Symbol">=</a> <a id="10831" href="Tactic.RingSolver.html#10235" class="Function">solve-∀-macro</a>

<a id="10846" class="Comment">------------------------------------------------------------------------</a>
<a id="10919" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10942" href="Tactic.RingSolver.html#10942" class="Function">malformedArgumentListError</a> <a id="10969" class="Symbol">:</a> <a id="10971" class="Symbol">∀</a> <a id="10973" class="Symbol">{</a><a id="10974" href="Tactic.RingSolver.html#10974" class="Bound">a</a><a id="10975" class="Symbol">}</a> <a id="10977" class="Symbol">{</a><a id="10978" href="Tactic.RingSolver.html#10978" class="Bound">A</a> <a id="10980" class="Symbol">:</a> <a id="10982" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="10986" href="Tactic.RingSolver.html#10974" class="Bound">a</a><a id="10987" class="Symbol">}</a> <a id="10989" class="Symbol">→</a> <a id="10991" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10996" class="Symbol">→</a> <a id="10998" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11001" href="Tactic.RingSolver.html#10978" class="Bound">A</a>
<a id="11003" href="Tactic.RingSolver.html#10942" class="Function">malformedArgumentListError</a> <a id="11030" href="Tactic.RingSolver.html#11030" class="Bound">found</a> <a id="11036" class="Symbol">=</a> <a id="11038" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11050" class="Symbol">(</a> <a id="11052" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11059" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11088" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11090" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11097" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11152" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11154" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11161" class="String">&quot;Instead: &quot;</a>
  <a id="11175" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11177" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11185" href="Tactic.RingSolver.html#11030" class="Bound">found</a>
  <a id="11193" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11195" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11197" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11200" href="Tactic.RingSolver.html#11200" class="Function">malformedGoalError</a> <a id="11219" class="Symbol">:</a> <a id="11221" class="Symbol">∀</a> <a id="11223" class="Symbol">{</a><a id="11224" href="Tactic.RingSolver.html#11224" class="Bound">a</a><a id="11225" class="Symbol">}</a> <a id="11227" class="Symbol">{</a><a id="11228" href="Tactic.RingSolver.html#11228" class="Bound">A</a> <a id="11230" class="Symbol">:</a> <a id="11232" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11236" href="Tactic.RingSolver.html#11224" class="Bound">a</a><a id="11237" class="Symbol">}</a> <a id="11239" class="Symbol">→</a> <a id="11241" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11246" class="Symbol">→</a> <a id="11248" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11251" href="Tactic.RingSolver.html#11228" class="Bound">A</a>
<a id="11253" href="Tactic.RingSolver.html#11200" class="Function">malformedGoalError</a> <a id="11272" href="Tactic.RingSolver.html#11272" class="Bound">found</a> <a id="11278" class="Symbol">=</a> <a id="11280" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11292" class="Symbol">(</a> <a id="11294" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11301" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11330" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11332" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11339" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11386" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11388" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11395" class="String">&quot;Instead: &quot;</a>
  <a id="11409" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11411" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11419" href="Tactic.RingSolver.html#11272" class="Bound">found</a>
  <a id="11427" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11429" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11431" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11434" href="Tactic.RingSolver.html#11434" class="Function">checkIsListOfVariables</a> <a id="11457" class="Symbol">:</a> <a id="11459" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11464" class="Symbol">→</a> <a id="11466" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11471" class="Symbol">→</a> <a id="11473" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11476" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11481" href="Tactic.RingSolver.html#11434" class="Function">checkIsListOfVariables</a> <a id="11504" href="Tactic.RingSolver.html#11504" class="Bound">`ring</a> <a id="11510" href="Tactic.RingSolver.html#11510" class="Bound">`xs</a> <a id="11514" class="Symbol">=</a> <a id="11516" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="11526" href="Tactic.RingSolver.html#11510" class="Bound">`xs</a> <a id="11530" class="Symbol">(</a><a id="11531" href="Data.List.Reflection.html#462" class="Function">`List</a> <a id="11537" class="Symbol">(</a><a id="11538" href="Tactic.RingSolver.html#3128" class="Function">`Carrier</a> <a id="11547" href="Tactic.RingSolver.html#11504" class="Bound">`ring</a><a id="11552" class="Symbol">))</a> <a id="11555" href="Reflection.TCM.Syntax.html#667" class="Function Operator">&gt;&gt;=</a> <a id="11559" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a>

<a id="11570" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11628" href="Tactic.RingSolver.html#11628" class="Function">getVariableIndices</a> <a id="11647" class="Symbol">:</a> <a id="11649" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11654" class="Symbol">→</a> <a id="11656" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11662" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
<a id="11669" href="Tactic.RingSolver.html#11628" class="Function">getVariableIndices</a> <a id="11688" class="Symbol">=</a> <a id="11690" href="Tactic.RingSolver.html#11706" class="Function">go</a> <a id="11693" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="11698" class="Keyword">where</a>
  <a id="11706" href="Tactic.RingSolver.html#11706" class="Function">go</a> <a id="11709" class="Symbol">:</a> <a id="11711" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11718" class="Symbol">→</a> <a id="11720" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11725" class="Symbol">→</a> <a id="11727" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11733" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
  <a id="11742" href="Tactic.RingSolver.html#11706" class="Function">go</a> <a id="11745" href="Tactic.RingSolver.html#11745" class="Bound">t</a> <a id="11747" class="Symbol">(</a><a id="11748" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="11752" href="Tactic.RingSolver.html#11752" class="Bound">i</a> <a id="11754" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="11757" href="Data.List.Reflection.html#956" class="InductiveConstructor Operator">`∷`</a> <a id="11761" href="Tactic.RingSolver.html#11761" class="Bound">xs</a><a id="11763" class="Symbol">)</a> <a id="11765" class="Symbol">=</a> <a id="11767" href="Tactic.RingSolver.html#11706" class="Function">go</a> <a id="11770" class="Symbol">(</a><a id="11771" href="Tactic.RingSolver.Core.NatSet.html#2233" class="Function">insert</a> <a id="11778" href="Tactic.RingSolver.html#11752" class="Bound">i</a> <a id="11780" href="Tactic.RingSolver.html#11745" class="Bound">t</a><a id="11781" class="Symbol">)</a> <a id="11783" href="Tactic.RingSolver.html#11761" class="Bound">xs</a>
  <a id="11788" href="Tactic.RingSolver.html#11706" class="Function">go</a> <a id="11791" href="Tactic.RingSolver.html#11791" class="Bound">t</a> <a id="11793" href="Data.List.Reflection.html#912" class="InductiveConstructor">`[]`</a>              <a id="11811" class="Symbol">=</a> <a id="11813" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="11818" href="Tactic.RingSolver.html#11791" class="Bound">t</a>
  <a id="11822" href="Tactic.RingSolver.html#11706" class="CatchallClause Function">go</a><a id="11824" class="CatchallClause"> </a><a id="11825" class="CatchallClause Symbol">_</a><a id="11826" class="CatchallClause"> </a><a id="11827" class="CatchallClause Symbol">_</a>                 <a id="11845" class="Symbol">=</a> <a id="11847" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11856" href="Tactic.RingSolver.html#11856" class="Function">constructSolution</a> <a id="11874" class="Symbol">:</a> <a id="11876" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11881" class="Symbol">→</a> <a id="11883" href="Tactic.RingSolver.html#2573" class="Record">RingOperatorTerms</a> <a id="11901" class="Symbol">→</a> <a id="11903" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11910" class="Symbol">→</a> <a id="11912" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11917" class="Symbol">→</a> <a id="11919" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11924" class="Symbol">→</a> <a id="11926" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11929" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11934" href="Tactic.RingSolver.html#11856" class="Function">constructSolution</a> <a id="11952" href="Tactic.RingSolver.html#11952" class="Bound">`ring</a> <a id="11958" href="Tactic.RingSolver.html#11958" class="Bound">opTerms</a> <a id="11966" href="Tactic.RingSolver.html#11966" class="Bound">variables</a> <a id="11976" href="Tactic.RingSolver.html#11976" class="Bound">`lhs</a> <a id="11981" href="Tactic.RingSolver.html#11981" class="Bound">`rhs</a> <a id="11986" class="Symbol">=</a> <a id="11988" class="Keyword">do</a>
  <a id="11993" href="Tactic.RingSolver.html#11993" class="Bound">`lhsExpr</a> <a id="12002" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="12004" href="Tactic.RingSolver.html#12279" class="Function">conv</a> <a id="12009" href="Tactic.RingSolver.html#11976" class="Bound">`lhs</a>
  <a id="12016" href="Tactic.RingSolver.html#12016" class="Bound">`rhsExpr</a> <a id="12025" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="12027" href="Tactic.RingSolver.html#12279" class="Function">conv</a> <a id="12032" href="Tactic.RingSolver.html#11981" class="Bound">`rhs</a>
  <a id="12039" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="12046" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12048" href="Tactic.RingSolver.html#3300" class="Function">`trans</a> <a id="12055" href="Tactic.RingSolver.html#11952" class="Bound">`ring</a> <a id="12061" class="Symbol">(</a><a id="12062" href="Tactic.RingSolver.html#3232" class="Function">`sym</a> <a id="12067" href="Tactic.RingSolver.html#11952" class="Bound">`ring</a> <a id="12073" href="Tactic.RingSolver.html#11993" class="Bound">`lhsExpr</a><a id="12081" class="Symbol">)</a> <a id="12083" href="Tactic.RingSolver.html#12016" class="Bound">`rhsExpr</a>
  <a id="12094" class="Keyword">where</a>
  <a id="12102" href="Tactic.RingSolver.html#12102" class="Function">numVars</a> <a id="12110" class="Symbol">=</a> <a id="12112" href="Data.List.Base.html#4864" class="Function">List.length</a> <a id="12124" href="Tactic.RingSolver.html#11966" class="Bound">variables</a>

  <a id="12137" href="Tactic.RingSolver.html#12137" class="Function">varMap</a> <a id="12144" class="Symbol">:</a> <a id="12146" href="Tactic.RingSolver.html#1595" class="Function">VarMap</a>
  <a id="12155" href="Tactic.RingSolver.html#12137" class="Function">varMap</a> <a id="12162" href="Tactic.RingSolver.html#12162" class="Bound">i</a> <a id="12164" class="Symbol">=</a> <a id="12166" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="12176" class="Symbol">(λ</a> <a id="12179" href="Tactic.RingSolver.html#12179" class="Bound">x</a> <a id="12181" class="Symbol">→</a> <a id="12183" href="Tactic.RingSolver.html#4691" class="Function">`I</a> <a id="12186" href="Tactic.RingSolver.html#11952" class="Bound">`ring</a> <a id="12192" href="Tactic.RingSolver.html#12102" class="Function">numVars</a> <a id="12200" class="Symbol">(</a><a id="12201" href="Data.Nat.Reflection.html#719" class="Function">toFinTerm</a> <a id="12211" href="Tactic.RingSolver.html#12179" class="Bound">x</a><a id="12212" class="Symbol">))</a> <a id="12215" class="Symbol">(</a><a id="12216" href="Tactic.RingSolver.Core.NatSet.html#2881" class="Function">lookup</a> <a id="12223" href="Tactic.RingSolver.html#12162" class="Bound">i</a> <a id="12225" href="Tactic.RingSolver.html#11966" class="Bound">variables</a><a id="12234" class="Symbol">)</a>

  <a id="12239" href="Tactic.RingSolver.html#12239" class="Function">ρ</a> <a id="12241" class="Symbol">:</a> <a id="12243" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="12250" href="Tactic.RingSolver.html#12239" class="Function">ρ</a> <a id="12252" class="Symbol">=</a> <a id="12254" href="Tactic.RingSolver.html#2205" class="Function">curriedTerm</a> <a id="12266" href="Tactic.RingSolver.html#11966" class="Bound">variables</a>

  <a id="12279" href="Tactic.RingSolver.html#12279" class="Function">conv</a> <a id="12284" class="Symbol">=</a> <a id="12286" class="Symbol">λ</a> <a id="12288" href="Tactic.RingSolver.html#12288" class="Bound">t</a> <a id="12290" class="Symbol">→</a> <a id="12292" class="Keyword">do</a>
    <a id="12299" href="Tactic.RingSolver.html#12299" class="Bound">t&#39;</a> <a id="12302" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="12304" href="Tactic.RingSolver.html#5781" class="Function">convertTerm</a> <a id="12316" href="Tactic.RingSolver.html#11952" class="Bound">`ring</a> <a id="12322" href="Tactic.RingSolver.html#12102" class="Function">numVars</a> <a id="12330" href="Tactic.RingSolver.html#11958" class="Bound">opTerms</a> <a id="12338" href="Tactic.RingSolver.html#12137" class="Function">varMap</a> <a id="12345" href="Tactic.RingSolver.html#12288" class="Bound">t</a>
    <a id="12351" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="12358" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12360" href="Tactic.RingSolver.html#4836" class="Function">`correct</a> <a id="12369" href="Tactic.RingSolver.html#11952" class="Bound">`ring</a> <a id="12375" href="Tactic.RingSolver.html#12102" class="Function">numVars</a> <a id="12383" href="Tactic.RingSolver.html#12299" class="Bound">t&#39;</a> <a id="12386" href="Tactic.RingSolver.html#12239" class="Function">ρ</a>

<a id="12389" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="12471" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="12546" class="Comment">-- intermediate step. Call it like so:</a>
<a id="12585" class="Comment">--</a>
<a id="12588" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12640" class="Comment">--   lemma₃ x y = begin</a>
<a id="12664" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12723" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12777" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12808" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12831" class="Comment">--</a>
<a id="12834" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12901" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12937" href="Tactic.RingSolver.html#12937" class="Function">solve-macro</a> <a id="12949" class="Symbol">:</a> <a id="12951" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12956" class="Symbol">→</a> <a id="12958" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="12963" class="Symbol">→</a> <a id="12965" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12970" class="Symbol">→</a> <a id="12972" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="12975" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="12977" href="Tactic.RingSolver.html#12937" class="Function">solve-macro</a> <a id="12989" href="Tactic.RingSolver.html#12989" class="Bound">variables</a> <a id="12999" href="Tactic.RingSolver.html#12999" class="Bound">ring</a> <a id="13004" href="Tactic.RingSolver.html#13004" class="Bound">hole</a> <a id="13009" class="Symbol">=</a> <a id="13011" class="Keyword">do</a>
  <a id="13016" href="Tactic.RingSolver.html#13016" class="Bound">`ring</a> <a id="13022" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13024" href="Tactic.RingSolver.html#2683" class="Function">checkIsRing</a> <a id="13036" class="Symbol">(</a><a id="13037" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="13041" href="Tactic.RingSolver.html#12999" class="Bound">ring</a> <a id="13046" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="13048" class="Symbol">)</a>
  <a id="13052" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="13063" href="Tactic.RingSolver.html#13063" class="Bound">operatorTerms</a> <a id="13077" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13079" href="Tactic.RingSolver.html#3584" class="Function">getRingOperatorTerms</a> <a id="13100" href="Tactic.RingSolver.html#13016" class="Bound">`ring</a>

  <a id="13109" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13156" href="Tactic.RingSolver.html#13156" class="Bound">listOfVariables′</a> <a id="13173" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13175" href="Tactic.RingSolver.html#11434" class="Function">checkIsListOfVariables</a> <a id="13198" href="Tactic.RingSolver.html#13016" class="Bound">`ring</a> <a id="13204" href="Tactic.RingSolver.html#12989" class="Bound">variables</a>
  <a id="13216" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="13227" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13232" href="Tactic.RingSolver.html#13232" class="Bound">variableIndices</a> <a id="13248" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13250" href="Reflection.TCM.Syntax.html#508" class="Function">pure</a> <a id="13255" class="Symbol">(</a><a id="13256" href="Tactic.RingSolver.html#11628" class="Function">getVariableIndices</a> <a id="13275" href="Tactic.RingSolver.html#13156" class="Bound">listOfVariables′</a><a id="13291" class="Symbol">)</a>
    <a id="13297" class="Keyword">where</a> <a id="13303" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13311" class="Symbol">→</a> <a id="13313" href="Tactic.RingSolver.html#10942" class="Function">malformedArgumentListError</a> <a id="13340" href="Tactic.RingSolver.html#13156" class="Bound">listOfVariables′</a>

  <a id="13360" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13398" href="Tactic.RingSolver.html#13398" class="Bound">hole′</a> <a id="13404" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13406" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="13416" href="Tactic.RingSolver.html#13004" class="Bound">hole</a> <a id="13421" href="Reflection.TCM.Syntax.html#667" class="Function Operator">&gt;&gt;=</a> <a id="13425" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="13434" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13439" class="Symbol">(</a><a id="13440" href="Tactic.RingSolver.html#13440" class="Bound">lhs</a> <a id="13444" href="Data.Vec.Base.html#1091" class="InductiveConstructor Operator">∷</a> <a id="13446" href="Tactic.RingSolver.html#13446" class="Bound">rhs</a> <a id="13450" href="Data.Vec.Base.html#1091" class="InductiveConstructor Operator">∷</a> <a id="13452" href="Data.Vec.Base.html#1072" class="InductiveConstructor">[]</a><a id="13454" class="Symbol">)</a> <a id="13456" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13458" href="Reflection.TCM.Syntax.html#508" class="Function">pure</a> <a id="13463" class="Symbol">(</a><a id="13464" href="Tactic.RingSolver.html#1778" class="Function">getVisibleArgs</a> <a id="13479" class="Number">2</a> <a id="13481" href="Tactic.RingSolver.html#13398" class="Bound">hole′</a><a id="13486" class="Symbol">)</a>
    <a id="13492" class="Keyword">where</a> <a id="13498" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13506" class="Symbol">→</a> <a id="13508" href="Tactic.RingSolver.html#11200" class="Function">malformedGoalError</a> <a id="13527" href="Tactic.RingSolver.html#13398" class="Bound">hole′</a>

  <a id="13536" href="Tactic.RingSolver.html#13536" class="Bound">solution</a> <a id="13545" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13547" href="Tactic.RingSolver.html#11856" class="Function">constructSolution</a> <a id="13565" href="Tactic.RingSolver.html#13016" class="Bound">`ring</a> <a id="13571" href="Tactic.RingSolver.html#13063" class="Bound">operatorTerms</a> <a id="13585" href="Tactic.RingSolver.html#13232" class="Bound">variableIndices</a> <a id="13601" href="Tactic.RingSolver.html#13440" class="Bound">lhs</a> <a id="13605" href="Tactic.RingSolver.html#13446" class="Bound">rhs</a>
  <a id="13611" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="13617" href="Tactic.RingSolver.html#13004" class="Bound">hole</a> <a id="13622" href="Tactic.RingSolver.html#13536" class="Bound">solution</a>

<a id="13632" class="Keyword">macro</a>
  <a id="solve"></a><a id="13640" href="Tactic.RingSolver.html#13640" class="Function">solve</a> <a id="13646" class="Symbol">:</a> <a id="13648" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13653" class="Symbol">→</a> <a id="13655" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="13660" class="Symbol">→</a> <a id="13662" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13667" class="Symbol">→</a> <a id="13669" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="13672" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="13676" href="Tactic.RingSolver.html#13640" class="Function">solve</a> <a id="13682" class="Symbol">=</a> <a id="13684" href="Tactic.RingSolver.html#12937" class="Function">solve-macro</a>
</pre></body></html>