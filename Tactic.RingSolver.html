<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--without-K</a> <a id="296" class="Pragma">--safe</a> <a id="303" class="Symbol">#-}</a>

<a id="308" class="Keyword">module</a> <a id="315" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="333" class="Keyword">where</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Algebra.html" class="Module">Algebra</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="388" class="Symbol">as</a> <a id="391" class="Module">Fin</a>   <a id="397" class="Keyword">using</a> <a id="403" class="Symbol">(</a><a id="404" href="Data.Fin.Base.html#1214" class="Datatype">Fin</a><a id="407" class="Symbol">)</a>
<a id="409" class="Keyword">open</a> <a id="414" class="Keyword">import</a> <a id="421" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="437" class="Symbol">as</a> <a id="440" class="Module">Vec</a>   <a id="446" class="Keyword">using</a> <a id="452" class="Symbol">(</a><a id="453" href="Data.Vec.Base.html#1010" class="Datatype">Vec</a><a id="456" class="Symbol">;</a> <a id="458" href="Data.Vec.Base.html#1065" class="InductiveConstructor Operator">_∷_</a><a id="461" class="Symbol">;</a> <a id="463" href="Data.Vec.Base.html#1046" class="InductiveConstructor">[]</a><a id="465" class="Symbol">)</a>
<a id="467" class="Keyword">open</a> <a id="472" class="Keyword">import</a> <a id="479" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="495" class="Symbol">as</a> <a id="498" class="Module">List</a>  <a id="504" class="Keyword">using</a> <a id="510" class="Symbol">(</a><a id="511" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="515" class="Symbol">;</a> <a id="517" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="520" class="Symbol">;</a> <a id="522" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="524" class="Symbol">)</a>
<a id="526" class="Keyword">open</a> <a id="531" class="Keyword">import</a> <a id="538" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="554" class="Symbol">as</a> <a id="557" class="Module">Maybe</a> <a id="563" class="Keyword">using</a> <a id="569" class="Symbol">(</a><a id="570" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="575" class="Symbol">;</a> <a id="577" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="581" class="Symbol">;</a> <a id="583" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="590" class="Symbol">;</a> <a id="592" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a><a id="601" class="Symbol">)</a>
<a id="603" class="Keyword">open</a> <a id="608" class="Keyword">import</a> <a id="615" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>            <a id="640" class="Keyword">using</a> <a id="646" class="Symbol">(</a><a id="647" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="648" class="Symbol">;</a> <a id="650" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="653" class="Symbol">;</a> <a id="655" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="659" class="Symbol">;</a> <a id="661" href="Data.Nat.Base.html#1235" class="Primitive Operator">_&lt;ᵇ_</a><a id="665" class="Symbol">)</a>
<a id="667" class="Keyword">open</a> <a id="672" class="Keyword">import</a> <a id="679" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>           <a id="704" class="Keyword">using</a> <a id="710" class="Symbol">(</a><a id="711" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="715" class="Symbol">;</a> <a id="717" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="730" class="Symbol">;</a> <a id="732" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="736" class="Symbol">;</a> <a id="738" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="743" class="Symbol">)</a>
<a id="745" class="Keyword">open</a> <a id="750" class="Keyword">import</a> <a id="757" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>           <a id="782" class="Keyword">using</a> <a id="788" class="Symbol">(</a><a id="789" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="790" class="Symbol">)</a>
<a id="792" class="Keyword">open</a> <a id="797" class="Keyword">import</a> <a id="804" href="Data.String.html" class="Module">Data.String</a> <a id="816" class="Symbol">as</a> <a id="819" class="Module">String</a>    <a id="829" class="Keyword">using</a> <a id="835" class="Symbol">(</a><a id="836" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="842" class="Symbol">;</a> <a id="844" href="Data.String.Base.html#2366" class="Function Operator">_++_</a><a id="848" class="Symbol">;</a> <a id="850" href="Data.String.Base.html#2826" class="Function">parens</a><a id="856" class="Symbol">)</a>
<a id="858" class="Keyword">open</a> <a id="863" class="Keyword">import</a> <a id="870" href="Data.Product.html" class="Module">Data.Product</a>             <a id="895" class="Keyword">using</a> <a id="901" class="Symbol">(</a><a id="902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="905" class="Symbol">;</a> <a id="907" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="912" class="Symbol">)</a>
<a id="914" class="Keyword">open</a> <a id="919" class="Keyword">import</a> <a id="926" href="Function.html" class="Module">Function</a>
<a id="935" class="Keyword">open</a> <a id="940" class="Keyword">import</a> <a id="947" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="975" class="Keyword">open</a> <a id="980" class="Keyword">import</a> <a id="987" href="Reflection.html" class="Module">Reflection</a>
<a id="998" class="Keyword">open</a> <a id="1003" class="Keyword">import</a> <a id="1010" href="Reflection.Argument.html" class="Module">Reflection.Argument</a>
<a id="1030" class="Keyword">open</a> <a id="1035" class="Keyword">import</a> <a id="1042" href="Reflection.Term.html" class="Module">Reflection.Term</a> <a id="1058" class="Symbol">as</a> <a id="1061" class="Module">Term</a>
<a id="1066" class="Keyword">open</a> <a id="1071" class="Keyword">import</a> <a id="1078" href="Reflection.AlphaEquality.html" class="Module">Reflection.AlphaEquality</a>
<a id="1103" class="Keyword">open</a> <a id="1108" class="Keyword">import</a> <a id="1115" href="Reflection.Name.html" class="Module">Reflection.Name</a> <a id="1131" class="Symbol">as</a> <a id="1134" class="Module">Name</a>
<a id="1139" class="Keyword">open</a> <a id="1144" class="Keyword">import</a> <a id="1151" href="Reflection.TypeChecking.Monad.Syntax.html" class="Module">Reflection.TypeChecking.Monad.Syntax</a>
<a id="1188" class="Keyword">open</a> <a id="1193" class="Keyword">import</a> <a id="1200" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1220" class="Keyword">open</a> <a id="1225" class="Keyword">import</a> <a id="1232" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1253" class="Keyword">import</a> <a id="1260" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1280" class="Symbol">as</a> <a id="1283" class="Module">Vec</a>

<a id="1288" class="Keyword">open</a> <a id="1293" class="Keyword">import</a> <a id="1300" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1332" class="Keyword">renaming</a> <a id="1341" class="Symbol">(</a><a id="1342" href="Tactic.RingSolver.NonReflective.html#2953" class="Function">solve</a> <a id="1348" class="Symbol">to</a> <a id="1351" class="Function">solver</a><a id="1357" class="Symbol">)</a>
<a id="1359" class="Keyword">open</a> <a id="1364" class="Keyword">import</a> <a id="1371" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1416" class="Keyword">open</a> <a id="1421" class="Keyword">import</a> <a id="1428" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1458" class="Symbol">as</a> <a id="1461" class="Module">NatSet</a>

<a id="1469" class="Keyword">open</a> <a id="1474" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Module">AlmostCommutativeRing</a>

<a id="1497" class="Comment">------------------------------------------------------------------------</a>
<a id="1570" class="Comment">-- Utilities</a>

<a id="1584" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1594" href="Tactic.RingSolver.html#1594" class="Function">VarMap</a> <a id="1601" class="Symbol">:</a> <a id="1603" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="1609" href="Tactic.RingSolver.html#1594" class="Function">VarMap</a> <a id="1616" class="Symbol">=</a> <a id="1618" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1620" class="Symbol">→</a> <a id="1622" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1628" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1636" href="Tactic.RingSolver.html#1636" class="Function">getVisible</a> <a id="1647" class="Symbol">:</a> <a id="1649" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="1653" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1658" class="Symbol">→</a> <a id="1660" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1666" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="1673" href="Tactic.RingSolver.html#1636" class="Function">getVisible</a> <a id="1684" class="Symbol">(</a><a id="1685" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="1689" class="Symbol">(</a><a id="1690" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="1699" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="1707" class="Symbol">_)</a> <a id="1710" href="Tactic.RingSolver.html#1710" class="Bound">x</a><a id="1711" class="Symbol">)</a> <a id="1713" class="Symbol">=</a> <a id="1715" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1720" href="Tactic.RingSolver.html#1710" class="Bound">x</a>
  <a id="1724" href="Tactic.RingSolver.html#1636" class="CatchallClause Function">getVisible</a><a id="1734" class="CatchallClause"> </a><a id="1735" class="CatchallClause Symbol">_</a>                            <a id="1764" class="Symbol">=</a> <a id="1766" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1777" href="Tactic.RingSolver.html#1777" class="Function">getVisibleArgs</a> <a id="1792" class="Symbol">:</a> <a id="1794" class="Symbol">∀</a> <a id="1796" href="Tactic.RingSolver.html#1796" class="Bound">n</a> <a id="1798" class="Symbol">→</a> <a id="1800" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1805" class="Symbol">→</a> <a id="1807" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1813" class="Symbol">(</a><a id="1814" href="Data.Vec.Base.html#1010" class="Datatype">Vec</a> <a id="1818" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1823" href="Tactic.RingSolver.html#1796" class="Bound">n</a><a id="1824" class="Symbol">)</a>
  <a id="1828" href="Tactic.RingSolver.html#1777" class="Function">getVisibleArgs</a> <a id="1843" href="Tactic.RingSolver.html#1843" class="Bound">n</a> <a id="1845" class="Symbol">(</a><a id="1846" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="1850" class="Symbol">_</a> <a id="1852" href="Tactic.RingSolver.html#1852" class="Bound">xs</a><a id="1854" class="Symbol">)</a> <a id="1856" class="Symbol">=</a> <a id="1858" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="1868" href="Data.Vec.Base.html#8076" class="Function">Vec.reverse</a>
    <a id="1884" class="Symbol">(</a><a id="1885" href="Data.List.Base.html#4293" class="Function">List.foldl</a> <a id="1896" href="Tactic.RingSolver.html#1947" class="Function">f</a> <a id="1898" href="Tactic.RingSolver.html#2091" class="Function">c</a> <a id="1900" class="Symbol">(</a><a id="1901" href="Data.List.Base.html#1629" class="Function">List.mapMaybe</a> <a id="1915" href="Tactic.RingSolver.html#1636" class="Function">getVisible</a> <a id="1926" href="Tactic.RingSolver.html#1852" class="Bound">xs</a><a id="1928" class="Symbol">)</a> <a id="1930" href="Tactic.RingSolver.html#1843" class="Bound">n</a><a id="1931" class="Symbol">)</a>
    <a id="1937" class="Keyword">where</a>
    <a id="1947" href="Tactic.RingSolver.html#1947" class="Function">f</a> <a id="1949" class="Symbol">:</a> <a id="1951" class="Symbol">(∀</a> <a id="1954" href="Tactic.RingSolver.html#1954" class="Bound">n</a> <a id="1956" class="Symbol">→</a> <a id="1958" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1964" class="Symbol">(</a><a id="1965" href="Data.Vec.Base.html#1010" class="Datatype">Vec</a> <a id="1969" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1974" href="Tactic.RingSolver.html#1954" class="Bound">n</a><a id="1975" class="Symbol">))</a> <a id="1978" class="Symbol">→</a> <a id="1980" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1985" class="Symbol">→</a> <a id="1987" class="Symbol">∀</a> <a id="1989" href="Tactic.RingSolver.html#1989" class="Bound">n</a> <a id="1991" class="Symbol">→</a> <a id="1993" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1999" class="Symbol">(</a><a id="2000" href="Data.Vec.Base.html#1010" class="Datatype">Vec</a> <a id="2004" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2009" href="Tactic.RingSolver.html#1989" class="Bound">n</a><a id="2010" class="Symbol">)</a>
    <a id="2016" href="Tactic.RingSolver.html#1947" class="Function">f</a> <a id="2018" href="Tactic.RingSolver.html#2018" class="Bound">xs</a> <a id="2021" href="Tactic.RingSolver.html#2021" class="Bound">x</a> <a id="2023" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2031" class="Symbol">=</a> <a id="2033" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2038" href="Data.Vec.Base.html#1046" class="InductiveConstructor">[]</a>
    <a id="2045" href="Tactic.RingSolver.html#1947" class="Function">f</a> <a id="2047" href="Tactic.RingSolver.html#2047" class="Bound">xs</a> <a id="2050" href="Tactic.RingSolver.html#2050" class="Bound">x</a> <a id="2052" class="Symbol">(</a><a id="2053" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2057" href="Tactic.RingSolver.html#2057" class="Bound">n</a><a id="2058" class="Symbol">)</a> <a id="2060" class="Symbol">=</a> <a id="2062" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="2072" class="Symbol">(</a><a id="2073" href="Tactic.RingSolver.html#2050" class="Bound">x</a> <a id="2075" href="Data.Vec.Base.html#1065" class="InductiveConstructor Operator">∷_</a><a id="2077" class="Symbol">)</a> <a id="2079" class="Symbol">(</a><a id="2080" href="Tactic.RingSolver.html#2047" class="Bound">xs</a> <a id="2083" href="Tactic.RingSolver.html#2057" class="Bound">n</a><a id="2084" class="Symbol">)</a>

    <a id="2091" href="Tactic.RingSolver.html#2091" class="Function">c</a> <a id="2093" class="Symbol">:</a> <a id="2095" class="Symbol">∀</a> <a id="2097" href="Tactic.RingSolver.html#2097" class="Bound">n</a> <a id="2099" class="Symbol">→</a> <a id="2101" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2107" class="Symbol">(</a><a id="2108" href="Data.Vec.Base.html#1010" class="Datatype">Vec</a> <a id="2112" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2117" href="Tactic.RingSolver.html#2097" class="Bound">n</a><a id="2118" class="Symbol">)</a>
    <a id="2124" href="Tactic.RingSolver.html#2091" class="Function">c</a> <a id="2126" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="2135" class="Symbol">=</a> <a id="2137" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2142" href="Data.Vec.Base.html#1046" class="InductiveConstructor">[]</a>
    <a id="2149" href="Tactic.RingSolver.html#2091" class="Function">c</a> <a id="2151" class="Symbol">(</a><a id="2152" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2156" class="Symbol">_</a> <a id="2158" class="Symbol">)</a> <a id="2160" class="Symbol">=</a> <a id="2162" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
  <a id="2172" href="Tactic.RingSolver.html#1777" class="CatchallClause Function">getVisibleArgs</a><a id="2186" class="CatchallClause"> </a><a id="2187" class="CatchallClause Symbol">_</a><a id="2188" class="CatchallClause"> </a><a id="2189" class="CatchallClause Symbol">_</a> <a id="2191" class="Symbol">=</a> <a id="2193" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2204" href="Tactic.RingSolver.html#2204" class="Function">curriedTerm</a> <a id="2216" class="Symbol">:</a> <a id="2218" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="2225" class="Symbol">→</a> <a id="2227" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="2234" href="Tactic.RingSolver.html#2204" class="Function">curriedTerm</a> <a id="2246" class="Symbol">=</a> <a id="2248" href="Data.List.Base.html#4192" class="Function">List.foldr</a> <a id="2259" href="Tactic.RingSolver.html#2300" class="Function">go</a> <a id="2262" href="Data.Vec.Reflection.html#662" class="Function">Vec.`[]</a> <a id="2270" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2272" href="Tactic.RingSolver.Core.NatSet.html#3284" class="Function">NatSet.toList</a>
    <a id="2290" class="Keyword">where</a>
    <a id="2300" href="Tactic.RingSolver.html#2300" class="Function">go</a> <a id="2303" class="Symbol">:</a> <a id="2305" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2307" class="Symbol">→</a> <a id="2309" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2314" class="Symbol">→</a> <a id="2316" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
    <a id="2325" href="Tactic.RingSolver.html#2300" class="Function">go</a> <a id="2328" href="Tactic.RingSolver.html#2328" class="Bound">x</a> <a id="2330" href="Tactic.RingSolver.html#2330" class="Bound">xs</a> <a id="2333" class="Symbol">=</a> <a id="2335" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="2339" href="Tactic.RingSolver.html#2328" class="Bound">x</a> <a id="2341" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2344" href="Data.Vec.Reflection.html#712" class="Function Operator">Vec.`∷</a> <a id="2351" href="Tactic.RingSolver.html#2330" class="Bound">xs</a>

<a id="2355" class="Comment">------------------------------------------------------------------------</a>
<a id="2428" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2463" href="Tactic.RingSolver.html#2463" class="Function">`AlmostCommutativeRing</a> <a id="2486" class="Symbol">:</a> <a id="2488" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2493" href="Tactic.RingSolver.html#2463" class="Function">`AlmostCommutativeRing</a> <a id="2516" class="Symbol">=</a> <a id="2518" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="2522" class="Symbol">(</a><a id="2523" class="Keyword">quote</a> <a id="2529" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Record">AlmostCommutativeRing</a><a id="2550" class="Symbol">)</a> <a id="2552" class="Symbol">(</a><a id="2553" class="Number">2</a> <a id="2555" href="Reflection.Term.html#2487" class="Function Operator">⋯⟨∷⟩</a> <a id="2560" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2562" class="Symbol">)</a>

<a id="2565" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2572" href="Tactic.RingSolver.html#2572" class="Record">RingOperatorTerms</a> <a id="2590" class="Symbol">:</a> <a id="2592" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2596" class="Keyword">where</a>
  <a id="2604" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2616" href="Tactic.RingSolver.html#2616" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2644" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2654" href="Tactic.RingSolver.html#2654" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2658" href="Tactic.RingSolver.html#2658" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2662" href="Tactic.RingSolver.html#2662" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2666" href="Tactic.RingSolver.html#2666" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2670" href="Tactic.RingSolver.html#2670" class="Field">sub</a> <a id="2674" class="Symbol">:</a> <a id="2676" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2682" href="Tactic.RingSolver.html#2682" class="Function">checkIsRing</a> <a id="2694" class="Symbol">:</a> <a id="2696" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2701" class="Symbol">→</a> <a id="2703" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="2706" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2711" href="Tactic.RingSolver.html#2682" class="Function">checkIsRing</a> <a id="2723" href="Tactic.RingSolver.html#2723" class="Bound">ring</a> <a id="2728" class="Symbol">=</a> <a id="2730" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="2740" href="Tactic.RingSolver.html#2723" class="Bound">ring</a> <a id="2745" href="Tactic.RingSolver.html#2463" class="Function">`AlmostCommutativeRing</a>

<a id="2769" class="Keyword">module</a> <a id="RingReflection"></a><a id="2776" href="Tactic.RingSolver.html#2776" class="Module">RingReflection</a> <a id="2791" class="Symbol">(</a><a id="2792" href="Tactic.RingSolver.html#2792" class="Bound">`ring</a> <a id="2798" class="Symbol">:</a> <a id="2800" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="2804" class="Symbol">)</a> <a id="2806" class="Keyword">where</a>

  <a id="2815" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2883" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2950" class="Comment">-- the required ring arguments</a>
  <a id="2983" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3031" class="Keyword">infixr</a> <a id="3038" class="Number">6</a> <a id="3040" href="Tactic.RingSolver.html#3047" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3047" href="Tactic.RingSolver.html#3047" class="Function Operator">_$ʳ_</a> <a id="3052" class="Symbol">:</a> <a id="3054" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3059" class="Symbol">→</a> <a id="3061" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="3066" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3071" class="Symbol">→</a> <a id="3073" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3080" href="Tactic.RingSolver.html#3080" class="Bound">nm</a> <a id="3083" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3086" href="Tactic.RingSolver.html#3086" class="Bound">args</a> <a id="3091" class="Symbol">=</a> <a id="3093" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3097" href="Tactic.RingSolver.html#3080" class="Bound">nm</a> <a id="3100" class="Symbol">(</a><a id="3101" class="Number">2</a> <a id="3103" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3108" href="Tactic.RingSolver.html#2792" class="Bound">`ring</a> <a id="3114" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3118" href="Tactic.RingSolver.html#3086" class="Bound">args</a><a id="3122" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3127" href="Tactic.RingSolver.html#3127" class="Function">`Carrier</a> <a id="3136" class="Symbol">:</a> <a id="3138" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3145" href="Tactic.RingSolver.html#3127" class="Function">`Carrier</a> <a id="3154" class="Symbol">=</a> <a id="3156" class="Keyword">quote</a> <a id="3162" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1387" class="Field">Carrier</a> <a id="3170" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3173" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3179" href="Tactic.RingSolver.html#3179" class="Function">`refl</a> <a id="3185" class="Symbol">:</a> <a id="3187" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3194" href="Tactic.RingSolver.html#3179" class="Function">`refl</a> <a id="3200" class="Symbol">=</a> <a id="3202" class="Keyword">quote</a> <a id="3208" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2550" class="Function">refl</a> <a id="3213" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3216" class="Symbol">(</a><a id="3217" class="Number">1</a> <a id="3219" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3224" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3226" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3231" href="Tactic.RingSolver.html#3231" class="Function">`sym</a> <a id="3236" class="Symbol">:</a> <a id="3238" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3243" class="Symbol">→</a> <a id="3245" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3252" href="Tactic.RingSolver.html#3231" class="Function">`sym</a> <a id="3257" href="Tactic.RingSolver.html#3257" class="Bound">x≈y</a> <a id="3261" class="Symbol">=</a> <a id="3263" class="Keyword">quote</a> <a id="3269" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="3273" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3276" class="Symbol">(</a><a id="3277" class="Number">2</a> <a id="3279" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3284" href="Tactic.RingSolver.html#3257" class="Bound">x≈y</a> <a id="3288" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3292" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3294" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3299" href="Tactic.RingSolver.html#3299" class="Function">`trans</a> <a id="3306" class="Symbol">:</a> <a id="3308" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3313" class="Symbol">→</a> <a id="3315" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3320" class="Symbol">→</a> <a id="3322" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3329" href="Tactic.RingSolver.html#3299" class="Function">`trans</a> <a id="3336" href="Tactic.RingSolver.html#3336" class="Bound">x≈y</a> <a id="3340" href="Tactic.RingSolver.html#3340" class="Bound">y≈z</a> <a id="3344" class="Symbol">=</a> <a id="3346" class="Keyword">quote</a> <a id="3352" href="Relation.Binary.Structures.html#1620" class="Function">trans</a> <a id="3358" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3361" class="Symbol">(</a><a id="3362" class="Number">3</a> <a id="3364" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="3369" href="Tactic.RingSolver.html#3336" class="Bound">x≈y</a> <a id="3373" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3377" href="Tactic.RingSolver.html#3340" class="Bound">y≈z</a> <a id="3381" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3385" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3387" class="Symbol">)</a>

  <a id="3392" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3458" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3525" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3583" href="Tactic.RingSolver.html#3583" class="Function">getRingOperatorTerms</a> <a id="3604" class="Symbol">:</a> <a id="3606" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="3609" href="Tactic.RingSolver.html#2572" class="Record">RingOperatorTerms</a>
  <a id="3629" href="Tactic.RingSolver.html#3583" class="Function">getRingOperatorTerms</a> <a id="3650" class="Symbol">=</a> <a id="3652" class="Symbol">⦇</a>
    <a id="3658" href="Tactic.RingSolver.html#2616" class="InductiveConstructor Operator">add⇒</a> <a id="3663" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3673" class="Symbol">(</a><a id="3674" class="Keyword">quote</a> <a id="3680" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a>  <a id="3685" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3688" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3690" class="Symbol">)</a>
    <a id="3696" href="Tactic.RingSolver.html#2616" class="InductiveConstructor Operator">mul⇒</a> <a id="3701" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3711" class="Symbol">(</a><a id="3712" class="Keyword">quote</a> <a id="3718" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a>  <a id="3723" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3726" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3728" class="Symbol">)</a>
    <a id="3734" href="Tactic.RingSolver.html#2616" class="InductiveConstructor Operator">pow⇒</a> <a id="3739" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3749" class="Symbol">(</a><a id="3750" class="Keyword">quote</a> <a id="3756" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a>  <a id="3761" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3764" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3766" class="Symbol">)</a>
    <a id="3772" href="Tactic.RingSolver.html#2616" class="InductiveConstructor Operator">neg⇒</a> <a id="3777" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3787" class="Symbol">(</a><a id="3788" class="Keyword">quote</a> <a id="3794" class="Symbol">(</a><a id="3795" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="3797" class="Symbol">)</a> <a id="3799" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3802" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3804" class="Symbol">)</a>
    <a id="3810" href="Tactic.RingSolver.html#2616" class="InductiveConstructor Operator">sub⇒</a> <a id="3815" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3825" class="Symbol">(</a><a id="3826" class="Keyword">quote</a> <a id="3832" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function Operator">_-_</a>  <a id="3837" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="3840" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3842" class="Symbol">)</a>
    <a id="3848" class="Symbol">⦈</a>

<a id="3851" class="Comment">------------------------------------------------------------------------</a>
<a id="3924" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3965" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="3972" href="Tactic.RingSolver.html#3972" class="Module">RingSolverReflection</a> <a id="3993" class="Symbol">(</a><a id="3994" href="Tactic.RingSolver.html#3994" class="Bound">ring</a> <a id="3999" class="Symbol">:</a> <a id="4001" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4005" class="Symbol">)</a> <a id="4007" class="Symbol">(</a><a id="4008" href="Tactic.RingSolver.html#4008" class="Bound">numberOfVariables</a> <a id="4026" class="Symbol">:</a> <a id="4028" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4029" class="Symbol">)</a> <a id="4031" class="Keyword">where</a>
  <a id="4039" class="Keyword">open</a> <a id="4044" href="Tactic.RingSolver.html#2776" class="Module">RingReflection</a> <a id="4059" href="Tactic.RingSolver.html#3994" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4067" href="Tactic.RingSolver.html#4067" class="Function">`numberOfVariables</a> <a id="4086" class="Symbol">:</a> <a id="4088" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4095" href="Tactic.RingSolver.html#4067" class="Function">`numberOfVariables</a> <a id="4114" class="Symbol">=</a> <a id="4116" href="Data.Nat.Reflection.html#636" class="Function">toTerm</a> <a id="4123" href="Tactic.RingSolver.html#4008" class="Bound">numberOfVariables</a>

  <a id="4144" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4214" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4287" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4356" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4425" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4489" class="Keyword">infix</a> <a id="4495" class="Number">-1</a> <a id="4498" href="Tactic.RingSolver.html#4505" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4505" href="Tactic.RingSolver.html#4505" class="Function Operator">_$ᵉ_</a> <a id="4510" class="Symbol">:</a> <a id="4512" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4517" class="Symbol">→</a> <a id="4519" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4524" class="Symbol">(</a><a id="4525" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="4529" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4533" class="Symbol">)</a> <a id="4535" class="Symbol">→</a> <a id="4537" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4544" href="Tactic.RingSolver.html#4544" class="Bound">e</a> <a id="4546" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="4549" href="Tactic.RingSolver.html#4549" class="Bound">xs</a> <a id="4552" class="Symbol">=</a> <a id="4554" href="Agda.Builtin.Reflection.html#4846" class="InductiveConstructor">con</a> <a id="4558" href="Tactic.RingSolver.html#4544" class="Bound">e</a> <a id="4560" class="Symbol">(</a><a id="4561" class="Number">1</a> <a id="4563" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="4568" href="Tactic.RingSolver.html#3127" class="Function">`Carrier</a> <a id="4577" href="Reflection.Argument.html#1727" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4581" href="Tactic.RingSolver.html#4067" class="Function">`numberOfVariables</a> <a id="4600" href="Reflection.Argument.html#1727" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4604" href="Tactic.RingSolver.html#4549" class="Bound">xs</a><a id="4606" class="Symbol">)</a>

  <a id="4611" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4639" href="Tactic.RingSolver.html#4639" class="Function">`Κ</a> <a id="4642" class="Symbol">:</a> <a id="4644" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4649" class="Symbol">→</a> <a id="4651" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4658" href="Tactic.RingSolver.html#4639" class="Function">`Κ</a> <a id="4661" href="Tactic.RingSolver.html#4661" class="Bound">x</a> <a id="4663" class="Symbol">=</a> <a id="4665" class="Keyword">quote</a> <a id="4671" href="Tactic.RingSolver.Core.Expression.html#538" class="InductiveConstructor">Κ</a> <a id="4673" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="4676" class="Symbol">(</a><a id="4677" href="Tactic.RingSolver.html#4661" class="Bound">x</a> <a id="4679" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4683" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4685" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4690" href="Tactic.RingSolver.html#4690" class="Function">`I</a> <a id="4693" class="Symbol">:</a> <a id="4695" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4700" class="Symbol">→</a> <a id="4702" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4709" href="Tactic.RingSolver.html#4690" class="Function">`I</a> <a id="4712" href="Tactic.RingSolver.html#4712" class="Bound">x</a> <a id="4714" class="Symbol">=</a> <a id="4716" class="Keyword">quote</a> <a id="4722" href="Tactic.RingSolver.Core.Expression.html#589" class="InductiveConstructor">Ι</a> <a id="4724" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="4727" class="Symbol">(</a><a id="4728" href="Tactic.RingSolver.html#4712" class="Bound">x</a> <a id="4730" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4734" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4736" class="Symbol">)</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4741" href="Tactic.RingSolver.html#4741" class="Function Operator">_`⊜_</a> <a id="4746" class="Symbol">:</a> <a id="4748" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4753" class="Symbol">→</a> <a id="4755" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4760" class="Symbol">→</a> <a id="4762" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4769" href="Tactic.RingSolver.html#4769" class="Bound">x</a> <a id="4771" href="Tactic.RingSolver.html#4741" class="Function Operator">`⊜</a> <a id="4774" href="Tactic.RingSolver.html#4774" class="Bound">y</a> <a id="4776" class="Symbol">=</a> <a id="4778" class="Keyword">quote</a> <a id="4784" href="Tactic.RingSolver.NonReflective.html#3315" class="Function Operator">_⊜_</a>  <a id="4789" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="4792" class="Symbol">(</a><a id="4793" href="Tactic.RingSolver.html#4067" class="Function">`numberOfVariables</a> <a id="4812" href="Reflection.Argument.html#1727" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4816" href="Tactic.RingSolver.html#4769" class="Bound">x</a> <a id="4818" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4822" href="Tactic.RingSolver.html#4774" class="Bound">y</a> <a id="4824" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4828" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4830" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4835" href="Tactic.RingSolver.html#4835" class="Function">`correct</a> <a id="4844" class="Symbol">:</a> <a id="4846" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4851" class="Symbol">→</a> <a id="4853" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4858" class="Symbol">→</a> <a id="4860" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4867" href="Tactic.RingSolver.html#4835" class="Function">`correct</a> <a id="4876" href="Tactic.RingSolver.html#4876" class="Bound">x</a> <a id="4878" href="Tactic.RingSolver.html#4878" class="Bound">ρ</a> <a id="4880" class="Symbol">=</a> <a id="4882" class="Keyword">quote</a> <a id="4888" href="Tactic.RingSolver.NonReflective.html#2289" class="Function">Ops.correct</a> <a id="4900" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="4903" class="Symbol">(</a><a id="4904" class="Number">1</a> <a id="4906" href="Reflection.Term.html#2800" class="Function Operator">⋯⟅∷⟆</a> <a id="4911" href="Tactic.RingSolver.html#4876" class="Bound">x</a> <a id="4913" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4917" href="Tactic.RingSolver.html#4878" class="Bound">ρ</a> <a id="4919" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4923" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4925" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4930" href="Tactic.RingSolver.html#4930" class="Function">`solver</a> <a id="4938" class="Symbol">:</a> <a id="4940" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4945" class="Symbol">→</a> <a id="4947" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4952" class="Symbol">→</a> <a id="4954" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4961" href="Tactic.RingSolver.html#4930" class="Function">`solver</a> <a id="4969" href="Tactic.RingSolver.html#4969" class="Bound">`f</a> <a id="4972" href="Tactic.RingSolver.html#4972" class="Bound">`eq</a> <a id="4976" class="Symbol">=</a> <a id="4978" class="Keyword">quote</a> <a id="4984" href="Tactic.RingSolver.html#1351" class="Function">solver</a> <a id="4991" href="Tactic.RingSolver.html#3047" class="Function Operator">$ʳ</a> <a id="4994" class="Symbol">(</a><a id="4995" href="Tactic.RingSolver.html#4067" class="Function">`numberOfVariables</a> <a id="5014" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5018" href="Tactic.RingSolver.html#4969" class="Bound">`f</a> <a id="5021" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5025" href="Tactic.RingSolver.html#4972" class="Bound">`eq</a> <a id="5029" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5033" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5035" class="Symbol">)</a>

  <a id="5040" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5107" class="Comment">-- used internally by the solver.</a>
  <a id="5143" class="Comment">--</a>
  <a id="5148" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5214" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5277" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5343" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5411" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5478" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5540" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5581" class="Comment">--</a>
  <a id="5586" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5655" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5723" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5780" href="Tactic.RingSolver.html#5780" class="Function">convertTerm</a> <a id="5792" class="Symbol">:</a> <a id="5794" href="Tactic.RingSolver.html#2572" class="Record">RingOperatorTerms</a> <a id="5812" class="Symbol">→</a> <a id="5814" href="Tactic.RingSolver.html#1594" class="Function">VarMap</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5828" class="Symbol">→</a> <a id="5830" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5833" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="5840" href="Tactic.RingSolver.html#5780" class="Function">convertTerm</a> <a id="5852" href="Tactic.RingSolver.html#5852" class="Bound">operatorTerms</a> <a id="5866" href="Tactic.RingSolver.html#5866" class="Bound">varMap</a> <a id="5873" class="Symbol">=</a> <a id="5875" href="Tactic.RingSolver.html#5952" class="Function">convert</a>
    <a id="5887" class="Keyword">where</a>
    <a id="5897" class="Keyword">open</a> <a id="5902" href="Tactic.RingSolver.html#2572" class="Module">RingOperatorTerms</a> <a id="5920" href="Tactic.RingSolver.html#5852" class="Bound">operatorTerms</a>

    <a id="5939" class="Keyword">mutual</a>
      <a id="5952" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="5960" class="Symbol">:</a> <a id="5962" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5967" class="Symbol">→</a> <a id="5969" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5972" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="5983" class="Comment">-- First try and match directly against the fields</a>
      <a id="6040" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6048" class="Symbol">(</a><a id="6049" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6053" class="Symbol">(</a><a id="6054" class="Keyword">quote</a> <a id="6060" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a><a id="6063" class="Symbol">)</a> <a id="6065" href="Tactic.RingSolver.html#6065" class="Bound">xs</a><a id="6067" class="Symbol">)</a> <a id="6069" class="Symbol">=</a> <a id="6071" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="6082" class="Symbol">(</a><a id="6083" class="Keyword">quote</a> <a id="6089" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="6092" class="Symbol">)</a> <a id="6094" href="Tactic.RingSolver.html#6065" class="Bound">xs</a>
      <a id="6103" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6111" class="Symbol">(</a><a id="6112" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6116" class="Symbol">(</a><a id="6117" class="Keyword">quote</a> <a id="6123" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a><a id="6126" class="Symbol">)</a> <a id="6128" href="Tactic.RingSolver.html#6128" class="Bound">xs</a><a id="6130" class="Symbol">)</a> <a id="6132" class="Symbol">=</a> <a id="6134" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="6145" class="Symbol">(</a><a id="6146" class="Keyword">quote</a> <a id="6152" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="6155" class="Symbol">)</a> <a id="6157" href="Tactic.RingSolver.html#6128" class="Bound">xs</a>
      <a id="6166" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6174" class="Symbol">(</a><a id="6175" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6179" class="Symbol">(</a><a id="6180" class="Keyword">quote</a>  <a id="6187" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="6189" class="Symbol">)</a> <a id="6191" href="Tactic.RingSolver.html#6191" class="Bound">xs</a><a id="6193" class="Symbol">)</a> <a id="6195" class="Symbol">=</a> <a id="6197" href="Tactic.RingSolver.html#7330" class="Function">convertOp₁</a> <a id="6208" class="Symbol">(</a><a id="6209" class="Keyword">quote</a>  <a id="6216" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="6218" class="Symbol">)</a> <a id="6220" href="Tactic.RingSolver.html#6191" class="Bound">xs</a>
      <a id="6229" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6237" class="Symbol">(</a><a id="6238" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6242" class="Symbol">(</a><a id="6243" class="Keyword">quote</a> <a id="6249" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a><a id="6252" class="Symbol">)</a> <a id="6254" href="Tactic.RingSolver.html#6254" class="Bound">xs</a><a id="6256" class="Symbol">)</a> <a id="6258" class="Symbol">=</a> <a id="6260" href="Tactic.RingSolver.html#7569" class="Function">convertExp</a> <a id="6271" href="Tactic.RingSolver.html#6254" class="Bound">xs</a>
      <a id="6280" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6288" class="Symbol">(</a><a id="6289" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6293" class="Symbol">(</a><a id="6294" class="Keyword">quote</a> <a id="6300" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function Operator">_-_</a><a id="6303" class="Symbol">)</a> <a id="6305" href="Tactic.RingSolver.html#6305" class="Bound">xs</a><a id="6307" class="Symbol">)</a> <a id="6309" class="Symbol">=</a> <a id="6311" href="Tactic.RingSolver.html#7820" class="Function">convertSub</a> <a id="6322" href="Tactic.RingSolver.html#6305" class="Bound">xs</a>
      <a id="6331" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6409" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6417" class="Symbol">(</a><a id="6418" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6422" href="Tactic.RingSolver.html#6422" class="Bound">nm</a>          <a id="6434" href="Tactic.RingSolver.html#6434" class="Bound">xs</a><a id="6436" class="Symbol">)</a> <a id="6438" class="Symbol">=</a> <a id="6440" href="Tactic.RingSolver.html#8121" class="Function">convertUnknownName</a> <a id="6459" href="Tactic.RingSolver.html#6422" class="Bound">nm</a> <a id="6462" href="Tactic.RingSolver.html#6434" class="Bound">xs</a>
      <a id="6471" class="Comment">-- Variables</a>
      <a id="6490" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6498" href="Tactic.RingSolver.html#6498" class="Bound">v</a><a id="6499" class="Symbol">@(</a><a id="6501" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="6505" href="Tactic.RingSolver.html#6505" class="Bound">x</a> <a id="6507" class="Symbol">_)</a>          <a id="6519" class="Symbol">=</a> <a id="6521" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="6528" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6530" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a> <a id="6540" class="Symbol">(</a><a id="6541" href="Tactic.RingSolver.html#4639" class="Function">`Κ</a> <a id="6544" href="Tactic.RingSolver.html#6498" class="Bound">v</a><a id="6545" class="Symbol">)</a> <a id="6547" class="Symbol">(</a><a id="6548" href="Tactic.RingSolver.html#5866" class="Bound">varMap</a> <a id="6555" href="Tactic.RingSolver.html#6505" class="Bound">x</a><a id="6556" class="Symbol">)</a>
      <a id="6564" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6618" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="6626" class="Symbol">(</a><a id="6627" href="Data.Nat.Reflection.html#599" class="InductiveConstructor">`suc</a> <a id="6632" href="Tactic.RingSolver.html#6632" class="Bound">x</a><a id="6633" class="Symbol">)</a>             <a id="6647" class="Symbol">=</a> <a id="6649" href="Tactic.RingSolver.html#8644" class="Function">convertSuc</a> <a id="6660" href="Tactic.RingSolver.html#6632" class="Bound">x</a>
      <a id="6668" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6726" href="Tactic.RingSolver.html#5952" class="CatchallClause Function">convert</a><a id="6733" class="CatchallClause"> </a><a id="6734" href="Tactic.RingSolver.html#6734" class="CatchallClause Bound">t</a>                    <a id="6755" class="Symbol">=</a> <a id="6757" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="6764" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6766" href="Tactic.RingSolver.html#4639" class="Function">`Κ</a> <a id="6769" href="Tactic.RingSolver.html#6734" class="Bound">t</a>

      <a id="6778" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6847" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6917" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="6986" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7043" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="7054" class="Symbol">:</a> <a id="7056" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7061" class="Symbol">→</a> <a id="7063" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7068" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7073" class="Symbol">→</a> <a id="7075" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7078" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7089" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="7100" href="Tactic.RingSolver.html#7100" class="Bound">nm</a> <a id="7103" class="Symbol">(</a><a id="7104" href="Tactic.RingSolver.html#7104" class="Bound">x</a> <a id="7106" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7110" href="Tactic.RingSolver.html#7110" class="Bound">y</a> <a id="7112" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7116" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7118" class="Symbol">)</a> <a id="7120" class="Symbol">=</a> <a id="7122" class="Keyword">do</a>
        <a id="7133" href="Tactic.RingSolver.html#7133" class="Bound">x&#39;</a> <a id="7136" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7138" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="7146" href="Tactic.RingSolver.html#7104" class="Bound">x</a>
        <a id="7156" href="Tactic.RingSolver.html#7156" class="Bound">y&#39;</a> <a id="7159" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7161" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="7169" href="Tactic.RingSolver.html#7110" class="Bound">y</a>
        <a id="7179" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7186" class="Symbol">(</a><a id="7187" href="Tactic.RingSolver.html#7100" class="Bound">nm</a> <a id="7190" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="7193" class="Symbol">(</a><a id="7194" href="Tactic.RingSolver.html#7133" class="Bound">x&#39;</a> <a id="7197" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7201" href="Tactic.RingSolver.html#7156" class="Bound">y&#39;</a> <a id="7204" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7208" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7210" class="Symbol">))</a>
      <a id="7219" href="Tactic.RingSolver.html#7043" class="CatchallClause Function">convertOp₂</a><a id="7229" class="CatchallClause"> </a><a id="7230" href="Tactic.RingSolver.html#7230" class="CatchallClause Bound">nm</a><a id="7232" class="CatchallClause"> </a><a id="7233" class="CatchallClause Symbol">(</a><a id="7234" href="Tactic.RingSolver.html#7234" class="CatchallClause Bound">x</a><a id="7235" class="CatchallClause"> </a><a id="7236" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7237" class="CatchallClause"> </a><a id="7238" href="Tactic.RingSolver.html#7238" class="CatchallClause Bound">xs</a><a id="7240" class="CatchallClause Symbol">)</a>         <a id="7250" class="Symbol">=</a> <a id="7252" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="7263" href="Tactic.RingSolver.html#7230" class="Bound">nm</a> <a id="7266" href="Tactic.RingSolver.html#7238" class="Bound">xs</a>
      <a id="7275" href="Tactic.RingSolver.html#7043" class="CatchallClause Function">convertOp₂</a><a id="7285" class="CatchallClause"> </a><a id="7286" class="CatchallClause Symbol">_</a><a id="7287" class="CatchallClause">  </a><a id="7289" class="CatchallClause Symbol">_</a>                <a id="7306" class="Symbol">=</a> <a id="7308" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7315" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7330" href="Tactic.RingSolver.html#7330" class="Function">convertOp₁</a> <a id="7341" class="Symbol">:</a> <a id="7343" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7348" class="Symbol">→</a> <a id="7350" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7355" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7360" class="Symbol">→</a> <a id="7362" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7365" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7376" href="Tactic.RingSolver.html#7330" class="Function">convertOp₁</a> <a id="7387" href="Tactic.RingSolver.html#7387" class="Bound">nm</a> <a id="7390" class="Symbol">(</a><a id="7391" href="Tactic.RingSolver.html#7391" class="Bound">x</a> <a id="7393" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7397" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7399" class="Symbol">)</a> <a id="7401" class="Symbol">=</a> <a id="7403" class="Keyword">do</a>
        <a id="7414" href="Tactic.RingSolver.html#7414" class="Bound">x&#39;</a> <a id="7417" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7419" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="7427" href="Tactic.RingSolver.html#7391" class="Bound">x</a>
        <a id="7437" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7444" class="Symbol">(</a><a id="7445" href="Tactic.RingSolver.html#7387" class="Bound">nm</a> <a id="7448" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="7451" class="Symbol">(</a><a id="7452" href="Tactic.RingSolver.html#7414" class="Bound">x&#39;</a> <a id="7455" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7459" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7461" class="Symbol">))</a>
      <a id="7470" href="Tactic.RingSolver.html#7330" class="CatchallClause Function">convertOp₁</a><a id="7480" class="CatchallClause"> </a><a id="7481" href="Tactic.RingSolver.html#7481" class="CatchallClause Bound">nm</a><a id="7483" class="CatchallClause"> </a><a id="7484" class="CatchallClause Symbol">(</a><a id="7485" href="Tactic.RingSolver.html#7485" class="CatchallClause Bound">x</a><a id="7486" class="CatchallClause"> </a><a id="7487" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7488" class="CatchallClause"> </a><a id="7489" href="Tactic.RingSolver.html#7489" class="CatchallClause Bound">xs</a><a id="7491" class="CatchallClause Symbol">)</a>   <a id="7495" class="Symbol">=</a> <a id="7497" href="Tactic.RingSolver.html#7330" class="Function">convertOp₁</a> <a id="7508" href="Tactic.RingSolver.html#7481" class="Bound">nm</a> <a id="7511" href="Tactic.RingSolver.html#7489" class="Bound">xs</a>
      <a id="7520" href="Tactic.RingSolver.html#7330" class="CatchallClause Function">convertOp₁</a><a id="7530" class="CatchallClause"> </a><a id="7531" class="CatchallClause Symbol">_</a><a id="7532" class="CatchallClause">  </a><a id="7534" class="CatchallClause Symbol">_</a>          <a id="7545" class="Symbol">=</a> <a id="7547" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7554" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7569" href="Tactic.RingSolver.html#7569" class="Function">convertExp</a> <a id="7580" class="Symbol">:</a> <a id="7582" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7587" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7592" class="Symbol">→</a> <a id="7594" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7597" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7608" href="Tactic.RingSolver.html#7569" class="Function">convertExp</a> <a id="7619" class="Symbol">(</a><a id="7620" href="Tactic.RingSolver.html#7620" class="Bound">x</a> <a id="7622" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7626" href="Tactic.RingSolver.html#7626" class="Bound">y</a> <a id="7628" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7632" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7634" class="Symbol">)</a> <a id="7636" class="Symbol">=</a> <a id="7638" class="Keyword">do</a>
        <a id="7649" href="Tactic.RingSolver.html#7649" class="Bound">x&#39;</a> <a id="7652" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7654" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="7662" href="Tactic.RingSolver.html#7620" class="Bound">x</a>
        <a id="7672" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7679" class="Symbol">(</a><a id="7680" class="Keyword">quote</a> <a id="7686" href="Tactic.RingSolver.Core.Expression.html#748" class="InductiveConstructor Operator">_⊛_</a> <a id="7690" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="7693" class="Symbol">(</a><a id="7694" href="Tactic.RingSolver.html#7649" class="Bound">x&#39;</a> <a id="7697" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7701" href="Tactic.RingSolver.html#7626" class="Bound">y</a> <a id="7703" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7707" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7709" class="Symbol">))</a>
      <a id="7718" href="Tactic.RingSolver.html#7569" class="CatchallClause Function">convertExp</a><a id="7728" class="CatchallClause"> </a><a id="7729" class="CatchallClause Symbol">(</a><a id="7730" href="Tactic.RingSolver.html#7730" class="CatchallClause Bound">x</a><a id="7731" class="CatchallClause"> </a><a id="7732" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7733" class="CatchallClause"> </a><a id="7734" href="Tactic.RingSolver.html#7734" class="CatchallClause Bound">xs</a><a id="7736" class="CatchallClause Symbol">)</a>         <a id="7746" class="Symbol">=</a> <a id="7748" href="Tactic.RingSolver.html#7569" class="Function">convertExp</a> <a id="7759" href="Tactic.RingSolver.html#7734" class="Bound">xs</a>
      <a id="7768" href="Tactic.RingSolver.html#7569" class="CatchallClause Function">convertExp</a><a id="7778" class="CatchallClause"> </a><a id="7779" class="CatchallClause Symbol">_</a>                <a id="7796" class="Symbol">=</a> <a id="7798" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7805" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7820" href="Tactic.RingSolver.html#7820" class="Function">convertSub</a> <a id="7831" class="Symbol">:</a> <a id="7833" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="7838" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7843" class="Symbol">→</a> <a id="7845" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7848" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7859" href="Tactic.RingSolver.html#7820" class="Function">convertSub</a> <a id="7870" class="Symbol">(</a><a id="7871" href="Tactic.RingSolver.html#7871" class="Bound">x</a> <a id="7873" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7877" href="Tactic.RingSolver.html#7877" class="Bound">y</a> <a id="7879" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7883" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7885" class="Symbol">)</a> <a id="7887" class="Symbol">=</a> <a id="7889" class="Keyword">do</a>
        <a id="7900" href="Tactic.RingSolver.html#7900" class="Bound">x&#39;</a>  <a id="7904" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7906" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="7914" href="Tactic.RingSolver.html#7871" class="Bound">x</a>
        <a id="7924" href="Tactic.RingSolver.html#7924" class="Bound">-y&#39;</a> <a id="7928" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="7930" href="Tactic.RingSolver.html#7330" class="Function">convertOp₁</a> <a id="7941" class="Symbol">(</a><a id="7942" class="Keyword">quote</a> <a id="7948" class="Symbol">(</a><a id="7949" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="7951" class="Symbol">))</a> <a id="7954" class="Symbol">(</a><a id="7955" href="Tactic.RingSolver.html#7877" class="Bound">y</a> <a id="7957" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7961" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7963" class="Symbol">)</a>
        <a id="7973" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="7980" class="Symbol">(</a><a id="7981" class="Keyword">quote</a> <a id="7987" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="7991" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="7994" href="Tactic.RingSolver.html#7900" class="Bound">x&#39;</a> <a id="7997" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8001" href="Tactic.RingSolver.html#7924" class="Bound">-y&#39;</a> <a id="8005" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8009" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8011" class="Symbol">)</a>
      <a id="8019" href="Tactic.RingSolver.html#7820" class="CatchallClause Function">convertSub</a><a id="8029" class="CatchallClause"> </a><a id="8030" class="CatchallClause Symbol">(</a><a id="8031" href="Tactic.RingSolver.html#8031" class="CatchallClause Bound">x</a><a id="8032" class="CatchallClause"> </a><a id="8033" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8034" class="CatchallClause"> </a><a id="8035" href="Tactic.RingSolver.html#8035" class="CatchallClause Bound">xs</a><a id="8037" class="CatchallClause Symbol">)</a>         <a id="8047" class="Symbol">=</a> <a id="8049" href="Tactic.RingSolver.html#7820" class="Function">convertSub</a> <a id="8060" href="Tactic.RingSolver.html#8035" class="Bound">xs</a>
      <a id="8069" href="Tactic.RingSolver.html#7820" class="CatchallClause Function">convertSub</a><a id="8079" class="CatchallClause"> </a><a id="8080" class="CatchallClause Symbol">_</a>                <a id="8097" class="Symbol">=</a> <a id="8099" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="8106" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="8121" href="Tactic.RingSolver.html#8121" class="Function">convertUnknownName</a> <a id="8140" class="Symbol">:</a> <a id="8142" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="8147" class="Symbol">→</a> <a id="8149" href="Reflection.Argument.html#1514" class="Function">Args</a> <a id="8154" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8159" class="Symbol">→</a> <a id="8161" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8164" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8175" href="Tactic.RingSolver.html#8121" class="Function">convertUnknownName</a> <a id="8194" href="Tactic.RingSolver.html#8194" class="Bound">nm</a> <a id="8197" href="Tactic.RingSolver.html#8197" class="Bound">xs</a> <a id="8200" class="Symbol">=</a> <a id="8202" class="Keyword">do</a>
        <a id="8213" href="Tactic.RingSolver.html#8213" class="Bound">nameTerm</a> <a id="8222" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="8224" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="8234" class="Symbol">(</a><a id="8235" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8239" href="Tactic.RingSolver.html#8194" class="Bound">nm</a> <a id="8242" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8244" class="Symbol">)</a>
        <a id="8254" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8257" class="Symbol">(</a><a id="8258" href="Tactic.RingSolver.html#8213" class="Bound">nameTerm</a> <a id="8267" href="Reflection.AlphaEquality.html#1258" class="Field Operator">=α=</a> <a id="8271" href="Tactic.RingSolver.html#2654" class="Function">add</a><a id="8274" class="Symbol">)</a> <a id="8276" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8281" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="8292" class="Symbol">(</a><a id="8293" class="Keyword">quote</a> <a id="8299" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="8302" class="Symbol">)</a> <a id="8304" href="Tactic.RingSolver.html#8197" class="Bound">xs</a> <a id="8307" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
          <a id="8322" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8325" class="Symbol">(</a><a id="8326" href="Tactic.RingSolver.html#8213" class="Bound">nameTerm</a> <a id="8335" href="Reflection.AlphaEquality.html#1258" class="Field Operator">=α=</a> <a id="8339" href="Tactic.RingSolver.html#2658" class="Function">mul</a><a id="8342" class="Symbol">)</a> <a id="8344" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8349" href="Tactic.RingSolver.html#7043" class="Function">convertOp₂</a> <a id="8360" class="Symbol">(</a><a id="8361" class="Keyword">quote</a> <a id="8367" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="8370" class="Symbol">)</a> <a id="8372" href="Tactic.RingSolver.html#8197" class="Bound">xs</a> <a id="8375" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
            <a id="8392" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8395" class="Symbol">(</a><a id="8396" href="Tactic.RingSolver.html#8213" class="Bound">nameTerm</a> <a id="8405" href="Reflection.AlphaEquality.html#1258" class="Field Operator">=α=</a> <a id="8409" href="Tactic.RingSolver.html#2666" class="Function">neg</a><a id="8412" class="Symbol">)</a> <a id="8414" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8419" href="Tactic.RingSolver.html#7330" class="Function">convertOp₁</a> <a id="8430" class="Symbol">(</a><a id="8431" class="Keyword">quote</a> <a id="8437" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="8439" class="Symbol">)</a>  <a id="8442" href="Tactic.RingSolver.html#8197" class="Bound">xs</a> <a id="8445" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
              <a id="8464" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8467" class="Symbol">(</a><a id="8468" href="Tactic.RingSolver.html#8213" class="Bound">nameTerm</a> <a id="8477" href="Reflection.AlphaEquality.html#1258" class="Field Operator">=α=</a> <a id="8481" href="Tactic.RingSolver.html#2662" class="Function">pow</a><a id="8484" class="Symbol">)</a> <a id="8486" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8491" href="Tactic.RingSolver.html#7569" class="Function">convertExp</a>             <a id="8514" href="Tactic.RingSolver.html#8197" class="Bound">xs</a> <a id="8517" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                <a id="8538" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8541" class="Symbol">(</a><a id="8542" href="Tactic.RingSolver.html#8213" class="Bound">nameTerm</a> <a id="8551" href="Reflection.AlphaEquality.html#1258" class="Field Operator">=α=</a> <a id="8555" href="Tactic.RingSolver.html#2670" class="Function">sub</a><a id="8558" class="Symbol">)</a> <a id="8560" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8565" href="Tactic.RingSolver.html#7820" class="Function">convertSub</a>            <a id="8587" href="Tactic.RingSolver.html#8197" class="Bound">xs</a> <a id="8590" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                  <a id="8613" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="8620" class="Symbol">(</a><a id="8621" href="Tactic.RingSolver.html#4639" class="Function">`Κ</a> <a id="8624" class="Symbol">(</a><a id="8625" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8629" href="Tactic.RingSolver.html#8194" class="Bound">nm</a> <a id="8632" href="Tactic.RingSolver.html#8197" class="Bound">xs</a><a id="8634" class="Symbol">))</a>

      <a id="8644" href="Tactic.RingSolver.html#8644" class="Function">convertSuc</a> <a id="8655" class="Symbol">:</a> <a id="8657" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8662" class="Symbol">→</a> <a id="8664" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8667" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8678" href="Tactic.RingSolver.html#8644" class="Function">convertSuc</a> <a id="8689" href="Tactic.RingSolver.html#8689" class="Bound">x</a> <a id="8691" class="Symbol">=</a> <a id="8693" class="Keyword">do</a> <a id="8696" href="Tactic.RingSolver.html#8696" class="Bound">x&#39;</a> <a id="8699" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="8701" href="Tactic.RingSolver.html#5952" class="Function">convert</a> <a id="8709" href="Tactic.RingSolver.html#8689" class="Bound">x</a><a id="8710" class="Symbol">;</a> <a id="8712" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="8719" class="Symbol">(</a><a id="8720" class="Keyword">quote</a> <a id="8726" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="8730" href="Tactic.RingSolver.html#4505" class="Function Operator">$ᵉ</a> <a id="8733" class="Symbol">(</a><a id="8734" href="Tactic.RingSolver.html#4639" class="Function">`Κ</a> <a id="8737" class="Symbol">(</a><a id="8738" href="Data.Nat.Reflection.html#636" class="Function">toTerm</a> <a id="8745" class="Number">1</a><a id="8746" class="Symbol">)</a> <a id="8748" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8752" href="Tactic.RingSolver.html#8696" class="Bound">x&#39;</a> <a id="8755" href="Reflection.Argument.html#1631" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8759" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8761" class="Symbol">))</a>

<a id="8765" class="Comment">------------------------------------------------------------------------</a>
<a id="8838" class="Comment">-- Macros</a>
<a id="8848" class="Comment">------------------------------------------------------------------------</a>
<a id="8921" class="Comment">-- Quantified macro</a>

<a id="8942" class="Keyword">open</a> <a id="8947" href="Tactic.RingSolver.html#2776" class="Module">RingReflection</a>
<a id="8962" class="Keyword">open</a> <a id="8967" href="Tactic.RingSolver.html#3972" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="8989" href="Tactic.RingSolver.html#8989" class="Function">malformedForallTypeError</a> <a id="9014" class="Symbol">:</a> <a id="9016" class="Symbol">∀</a> <a id="9018" class="Symbol">{</a><a id="9019" href="Tactic.RingSolver.html#9019" class="Bound">a</a><a id="9020" class="Symbol">}</a> <a id="9022" class="Symbol">{</a><a id="9023" href="Tactic.RingSolver.html#9023" class="Bound">A</a> <a id="9025" class="Symbol">:</a> <a id="9027" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="9031" href="Tactic.RingSolver.html#9019" class="Bound">a</a><a id="9032" class="Symbol">}</a> <a id="9034" class="Symbol">→</a> <a id="9036" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9041" class="Symbol">→</a> <a id="9043" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9046" href="Tactic.RingSolver.html#9023" class="Bound">A</a>
<a id="9048" href="Tactic.RingSolver.html#8989" class="Function">malformedForallTypeError</a> <a id="9073" href="Tactic.RingSolver.html#9073" class="Bound">found</a> <a id="9079" class="Symbol">=</a> <a id="9081" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="9093" class="Symbol">(</a> <a id="9095" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9102" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9131" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9133" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9140" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9200" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9202" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9209" class="String">&quot;Instead: &quot;</a>
  <a id="9223" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9225" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9233" href="Tactic.RingSolver.html#9073" class="Bound">found</a>
  <a id="9241" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9243" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9245" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9248" href="Tactic.RingSolver.html#9248" class="Function">quantifiedVarMap</a> <a id="9265" class="Symbol">:</a> <a id="9267" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9269" class="Symbol">→</a> <a id="9271" href="Tactic.RingSolver.html#1594" class="Function">VarMap</a>
<a id="9278" href="Tactic.RingSolver.html#9248" class="Function">quantifiedVarMap</a> <a id="9295" href="Tactic.RingSolver.html#9295" class="Bound">numVars</a> <a id="9303" href="Tactic.RingSolver.html#9303" class="Bound">i</a> <a id="9305" class="Symbol">=</a>
  <a id="9309" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="9312" href="Tactic.RingSolver.html#9303" class="Bound">i</a> <a id="9314" href="Data.Nat.Base.html#1235" class="Primitive Operator">&lt;ᵇ</a> <a id="9317" href="Tactic.RingSolver.html#9295" class="Bound">numVars</a>
    <a id="9329" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="9334" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="9339" class="Symbol">(</a><a id="9340" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="9344" href="Tactic.RingSolver.html#9303" class="Bound">i</a> <a id="9346" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9348" class="Symbol">)</a>
    <a id="9354" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="9359" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9368" href="Tactic.RingSolver.html#9368" class="Function">constructCallToSolver</a> <a id="9390" class="Symbol">:</a> <a id="9392" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9397" class="Symbol">→</a> <a id="9399" href="Tactic.RingSolver.html#2572" class="Record">RingOperatorTerms</a> <a id="9417" class="Symbol">→</a> <a id="9419" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="9424" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="9431" class="Symbol">→</a> <a id="9433" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9438" class="Symbol">→</a> <a id="9440" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9445" class="Symbol">→</a> <a id="9447" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9450" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="9455" href="Tactic.RingSolver.html#9368" class="Function">constructCallToSolver</a> <a id="9477" href="Tactic.RingSolver.html#9477" class="Bound">`ring</a> <a id="9483" href="Tactic.RingSolver.html#9483" class="Bound">opNames</a> <a id="9491" href="Tactic.RingSolver.html#9491" class="Bound">variables</a> <a id="9501" href="Tactic.RingSolver.html#9501" class="Bound">`lhs</a> <a id="9506" href="Tactic.RingSolver.html#9506" class="Bound">`rhs</a> <a id="9511" class="Symbol">=</a> <a id="9513" class="Keyword">do</a>
  <a id="9518" href="Tactic.RingSolver.html#9518" class="Bound">`lhsExpr</a> <a id="9527" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9529" href="Tactic.RingSolver.html#9798" class="Function">conv</a> <a id="9534" href="Tactic.RingSolver.html#9501" class="Bound">`lhs</a>
  <a id="9541" href="Tactic.RingSolver.html#9541" class="Bound">`rhsExpr</a> <a id="9550" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="9552" href="Tactic.RingSolver.html#9798" class="Function">conv</a> <a id="9557" href="Tactic.RingSolver.html#9506" class="Bound">`rhs</a>

  <a id="9565" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="9572" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="9574" href="Tactic.RingSolver.html#4930" class="Function">`solver</a> <a id="9582" href="Tactic.RingSolver.html#9477" class="Bound">`ring</a> <a id="9588" href="Tactic.RingSolver.html#9749" class="Function">numVars</a>
                    <a id="9616" class="Symbol">(</a><a id="9617" href="Reflection.Term.html#3462" class="Function">prependVLams</a> <a id="9630" href="Tactic.RingSolver.html#9491" class="Bound">variables</a> <a id="9640" class="Symbol">(</a><a id="9641" href="Tactic.RingSolver.html#4741" class="Function Operator">_`⊜_</a> <a id="9646" href="Tactic.RingSolver.html#9477" class="Bound">`ring</a> <a id="9652" href="Tactic.RingSolver.html#9749" class="Function">numVars</a> <a id="9660" href="Tactic.RingSolver.html#9518" class="Bound">`lhsExpr</a> <a id="9669" href="Tactic.RingSolver.html#9541" class="Bound">`rhsExpr</a><a id="9677" class="Symbol">))</a>
                    <a id="9700" class="Symbol">(</a><a id="9701" href="Reflection.Term.html#3364" class="Function">prependHLams</a> <a id="9714" href="Tactic.RingSolver.html#9491" class="Bound">variables</a> <a id="9724" class="Symbol">(</a><a id="9725" href="Tactic.RingSolver.html#3179" class="Function">`refl</a> <a id="9731" href="Tactic.RingSolver.html#9477" class="Bound">`ring</a><a id="9736" class="Symbol">))</a>
  <a id="9741" class="Keyword">where</a>
  <a id="9749" href="Tactic.RingSolver.html#9749" class="Function">numVars</a> <a id="9757" class="Symbol">:</a> <a id="9759" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
  <a id="9763" href="Tactic.RingSolver.html#9749" class="Function">numVars</a> <a id="9771" class="Symbol">=</a> <a id="9773" href="Data.List.Base.html#4864" class="Function">List.length</a> <a id="9785" href="Tactic.RingSolver.html#9491" class="Bound">variables</a>

  <a id="9798" href="Tactic.RingSolver.html#9798" class="Function">conv</a> <a id="9803" class="Symbol">:</a> <a id="9805" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9810" class="Symbol">→</a> <a id="9812" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9815" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="9822" href="Tactic.RingSolver.html#9798" class="Function">conv</a> <a id="9827" class="Symbol">=</a> <a id="9829" href="Tactic.RingSolver.html#5780" class="Function">convertTerm</a> <a id="9841" href="Tactic.RingSolver.html#9477" class="Bound">`ring</a> <a id="9847" href="Tactic.RingSolver.html#9749" class="Function">numVars</a> <a id="9855" href="Tactic.RingSolver.html#9483" class="Bound">opNames</a> <a id="9863" class="Symbol">(</a><a id="9864" href="Tactic.RingSolver.html#9248" class="Function">quantifiedVarMap</a> <a id="9881" href="Tactic.RingSolver.html#9749" class="Function">numVars</a><a id="9888" class="Symbol">)</a>

<a id="9891" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9957" class="Comment">-- variables are universally quantified over:</a>
<a id="10003" class="Comment">--</a>
<a id="10006" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10041" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10067" class="Comment">--</a>
<a id="10070" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10133" class="Comment">-- (Find some example implementations in</a>
<a id="10174" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10234" href="Tactic.RingSolver.html#10234" class="Function">solve-∀-macro</a> <a id="10248" class="Symbol">:</a> <a id="10250" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10255" class="Symbol">→</a> <a id="10257" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10262" class="Symbol">→</a> <a id="10264" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10267" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="10269" href="Tactic.RingSolver.html#10234" class="Function">solve-∀-macro</a> <a id="10283" href="Tactic.RingSolver.html#10283" class="Bound">ring</a> <a id="10288" href="Tactic.RingSolver.html#10288" class="Bound">hole</a> <a id="10293" class="Symbol">=</a> <a id="10295" class="Keyword">do</a>
  <a id="10300" href="Tactic.RingSolver.html#10300" class="Bound">`ring</a> <a id="10306" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10308" href="Tactic.RingSolver.html#2682" class="Function">checkIsRing</a> <a id="10320" class="Symbol">(</a><a id="10321" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="10325" href="Tactic.RingSolver.html#10283" class="Bound">ring</a> <a id="10330" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10332" class="Symbol">)</a>
  <a id="10336" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="10347" href="Tactic.RingSolver.html#10347" class="Bound">operatorTerms</a> <a id="10361" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10363" href="Tactic.RingSolver.html#3583" class="Function">getRingOperatorTerms</a> <a id="10384" href="Tactic.RingSolver.html#10300" class="Bound">`ring</a>

  <a id="10393" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10432" href="Tactic.RingSolver.html#10432" class="Bound">`hole</a> <a id="10438" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10440" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="10450" href="Tactic.RingSolver.html#10288" class="Bound">hole</a> <a id="10455" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="10459" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="10468" class="Keyword">let</a> <a id="10472" href="Tactic.RingSolver.html#10472" class="Bound">variablesAndTypes</a> <a id="10490" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10492" href="Tactic.RingSolver.html#10492" class="Bound">equation</a> <a id="10501" class="Symbol">=</a> <a id="10503" href="Reflection.Term.html#3093" class="Function">stripPis</a> <a id="10512" href="Tactic.RingSolver.html#10432" class="Bound">`hole</a>

  <a id="10521" class="Keyword">let</a> <a id="10525" href="Tactic.RingSolver.html#10525" class="Bound">variables</a> <a id="10535" class="Symbol">=</a> <a id="10537" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="10546" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="10552" href="Tactic.RingSolver.html#10472" class="Bound">variablesAndTypes</a>
  <a id="10572" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10577" class="Symbol">(</a><a id="10578" href="Tactic.RingSolver.html#10578" class="Bound">lhs</a> <a id="10582" href="Data.Vec.Base.html#1065" class="InductiveConstructor Operator">∷</a> <a id="10584" href="Tactic.RingSolver.html#10584" class="Bound">rhs</a> <a id="10588" href="Data.Vec.Base.html#1065" class="InductiveConstructor Operator">∷</a> <a id="10590" href="Data.Vec.Base.html#1046" class="InductiveConstructor">[]</a><a id="10592" class="Symbol">)</a> <a id="10594" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10596" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="10601" class="Symbol">(</a><a id="10602" href="Tactic.RingSolver.html#1777" class="Function">getVisibleArgs</a> <a id="10617" class="Number">2</a> <a id="10619" href="Tactic.RingSolver.html#10492" class="Bound">equation</a><a id="10627" class="Symbol">)</a>
    <a id="10633" class="Keyword">where</a> <a id="10639" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="10647" class="Symbol">→</a> <a id="10649" href="Tactic.RingSolver.html#8989" class="Function">malformedForallTypeError</a> <a id="10674" href="Tactic.RingSolver.html#10432" class="Bound">`hole</a>

  <a id="10683" href="Tactic.RingSolver.html#10683" class="Bound">solverCall</a> <a id="10694" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="10696" href="Tactic.RingSolver.html#9368" class="Function">constructCallToSolver</a> <a id="10718" href="Tactic.RingSolver.html#10300" class="Bound">`ring</a> <a id="10724" href="Tactic.RingSolver.html#10347" class="Bound">operatorTerms</a> <a id="10738" href="Tactic.RingSolver.html#10525" class="Bound">variables</a> <a id="10748" href="Tactic.RingSolver.html#10578" class="Bound">lhs</a> <a id="10752" href="Tactic.RingSolver.html#10584" class="Bound">rhs</a>
  <a id="10758" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="10764" href="Tactic.RingSolver.html#10288" class="Bound">hole</a> <a id="10769" href="Tactic.RingSolver.html#10683" class="Bound">solverCall</a>

<a id="10781" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10789" href="Tactic.RingSolver.html#10789" class="Function">solve-∀</a> <a id="10797" class="Symbol">:</a> <a id="10799" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10804" class="Symbol">→</a> <a id="10806" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10811" class="Symbol">→</a> <a id="10813" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10816" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="10820" href="Tactic.RingSolver.html#10789" class="Function">solve-∀</a> <a id="10828" class="Symbol">=</a> <a id="10830" href="Tactic.RingSolver.html#10234" class="Function">solve-∀-macro</a>

<a id="10845" class="Comment">------------------------------------------------------------------------</a>
<a id="10918" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10941" href="Tactic.RingSolver.html#10941" class="Function">malformedArgumentListError</a> <a id="10968" class="Symbol">:</a> <a id="10970" class="Symbol">∀</a> <a id="10972" class="Symbol">{</a><a id="10973" href="Tactic.RingSolver.html#10973" class="Bound">a</a><a id="10974" class="Symbol">}</a> <a id="10976" class="Symbol">{</a><a id="10977" href="Tactic.RingSolver.html#10977" class="Bound">A</a> <a id="10979" class="Symbol">:</a> <a id="10981" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="10985" href="Tactic.RingSolver.html#10973" class="Bound">a</a><a id="10986" class="Symbol">}</a> <a id="10988" class="Symbol">→</a> <a id="10990" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10995" class="Symbol">→</a> <a id="10997" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11000" href="Tactic.RingSolver.html#10977" class="Bound">A</a>
<a id="11002" href="Tactic.RingSolver.html#10941" class="Function">malformedArgumentListError</a> <a id="11029" href="Tactic.RingSolver.html#11029" class="Bound">found</a> <a id="11035" class="Symbol">=</a> <a id="11037" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11049" class="Symbol">(</a> <a id="11051" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11058" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11087" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11089" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11096" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11151" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11153" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11160" class="String">&quot;Instead: &quot;</a>
  <a id="11174" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11176" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11184" href="Tactic.RingSolver.html#11029" class="Bound">found</a>
  <a id="11192" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11194" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11196" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11199" href="Tactic.RingSolver.html#11199" class="Function">malformedGoalError</a> <a id="11218" class="Symbol">:</a> <a id="11220" class="Symbol">∀</a> <a id="11222" class="Symbol">{</a><a id="11223" href="Tactic.RingSolver.html#11223" class="Bound">a</a><a id="11224" class="Symbol">}</a> <a id="11226" class="Symbol">{</a><a id="11227" href="Tactic.RingSolver.html#11227" class="Bound">A</a> <a id="11229" class="Symbol">:</a> <a id="11231" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11235" href="Tactic.RingSolver.html#11223" class="Bound">a</a><a id="11236" class="Symbol">}</a> <a id="11238" class="Symbol">→</a> <a id="11240" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11245" class="Symbol">→</a> <a id="11247" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11250" href="Tactic.RingSolver.html#11227" class="Bound">A</a>
<a id="11252" href="Tactic.RingSolver.html#11199" class="Function">malformedGoalError</a> <a id="11271" href="Tactic.RingSolver.html#11271" class="Bound">found</a> <a id="11277" class="Symbol">=</a> <a id="11279" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11291" class="Symbol">(</a> <a id="11293" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11300" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11329" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11331" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11338" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11385" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11387" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11394" class="String">&quot;Instead: &quot;</a>
  <a id="11408" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11410" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11418" href="Tactic.RingSolver.html#11271" class="Bound">found</a>
  <a id="11426" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11428" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11430" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11433" href="Tactic.RingSolver.html#11433" class="Function">checkIsListOfVariables</a> <a id="11456" class="Symbol">:</a> <a id="11458" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11463" class="Symbol">→</a> <a id="11465" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11470" class="Symbol">→</a> <a id="11472" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11475" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11480" href="Tactic.RingSolver.html#11433" class="Function">checkIsListOfVariables</a> <a id="11503" href="Tactic.RingSolver.html#11503" class="Bound">`ring</a> <a id="11509" href="Tactic.RingSolver.html#11509" class="Bound">`xs</a> <a id="11513" class="Symbol">=</a> <a id="11515" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="11525" href="Tactic.RingSolver.html#11509" class="Bound">`xs</a> <a id="11529" class="Symbol">(</a><a id="11530" href="Data.List.Reflection.html#454" class="Function">`List</a> <a id="11536" class="Symbol">(</a><a id="11537" href="Tactic.RingSolver.html#3127" class="Function">`Carrier</a> <a id="11546" href="Tactic.RingSolver.html#11503" class="Bound">`ring</a><a id="11551" class="Symbol">))</a> <a id="11554" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="11558" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a>

<a id="11569" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11627" href="Tactic.RingSolver.html#11627" class="Function">getVariableIndices</a> <a id="11646" class="Symbol">:</a> <a id="11648" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11653" class="Symbol">→</a> <a id="11655" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11661" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
<a id="11668" href="Tactic.RingSolver.html#11627" class="Function">getVariableIndices</a> <a id="11687" class="Symbol">=</a> <a id="11689" href="Tactic.RingSolver.html#11705" class="Function">go</a> <a id="11692" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="11697" class="Keyword">where</a>
  <a id="11705" href="Tactic.RingSolver.html#11705" class="Function">go</a> <a id="11708" class="Symbol">:</a> <a id="11710" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11717" class="Symbol">→</a> <a id="11719" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11724" class="Symbol">→</a> <a id="11726" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11732" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
  <a id="11741" href="Tactic.RingSolver.html#11705" class="Function">go</a> <a id="11744" href="Tactic.RingSolver.html#11744" class="Bound">t</a> <a id="11746" class="Symbol">(</a><a id="11747" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="11751" href="Tactic.RingSolver.html#11751" class="Bound">i</a> <a id="11753" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="11756" href="Data.List.Reflection.html#948" class="InductiveConstructor Operator">`∷`</a> <a id="11760" href="Tactic.RingSolver.html#11760" class="Bound">xs</a><a id="11762" class="Symbol">)</a> <a id="11764" class="Symbol">=</a> <a id="11766" href="Tactic.RingSolver.html#11705" class="Function">go</a> <a id="11769" class="Symbol">(</a><a id="11770" href="Tactic.RingSolver.Core.NatSet.html#2233" class="Function">insert</a> <a id="11777" href="Tactic.RingSolver.html#11751" class="Bound">i</a> <a id="11779" href="Tactic.RingSolver.html#11744" class="Bound">t</a><a id="11780" class="Symbol">)</a> <a id="11782" href="Tactic.RingSolver.html#11760" class="Bound">xs</a>
  <a id="11787" href="Tactic.RingSolver.html#11705" class="Function">go</a> <a id="11790" href="Tactic.RingSolver.html#11790" class="Bound">t</a> <a id="11792" href="Data.List.Reflection.html#904" class="InductiveConstructor">`[]`</a>              <a id="11810" class="Symbol">=</a> <a id="11812" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="11817" href="Tactic.RingSolver.html#11790" class="Bound">t</a>
  <a id="11821" href="Tactic.RingSolver.html#11705" class="CatchallClause Function">go</a><a id="11823" class="CatchallClause"> </a><a id="11824" class="CatchallClause Symbol">_</a><a id="11825" class="CatchallClause"> </a><a id="11826" class="CatchallClause Symbol">_</a>                 <a id="11844" class="Symbol">=</a> <a id="11846" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11855" href="Tactic.RingSolver.html#11855" class="Function">constructSolution</a> <a id="11873" class="Symbol">:</a> <a id="11875" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11880" class="Symbol">→</a> <a id="11882" href="Tactic.RingSolver.html#2572" class="Record">RingOperatorTerms</a> <a id="11900" class="Symbol">→</a> <a id="11902" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11909" class="Symbol">→</a> <a id="11911" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11916" class="Symbol">→</a> <a id="11918" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11923" class="Symbol">→</a> <a id="11925" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11928" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11933" href="Tactic.RingSolver.html#11855" class="Function">constructSolution</a> <a id="11951" href="Tactic.RingSolver.html#11951" class="Bound">`ring</a> <a id="11957" href="Tactic.RingSolver.html#11957" class="Bound">opTerms</a> <a id="11965" href="Tactic.RingSolver.html#11965" class="Bound">variables</a> <a id="11975" href="Tactic.RingSolver.html#11975" class="Bound">`lhs</a> <a id="11980" href="Tactic.RingSolver.html#11980" class="Bound">`rhs</a> <a id="11985" class="Symbol">=</a> <a id="11987" class="Keyword">do</a>
  <a id="11992" href="Tactic.RingSolver.html#11992" class="Bound">`lhsExpr</a> <a id="12001" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12003" href="Tactic.RingSolver.html#12278" class="Function">conv</a> <a id="12008" href="Tactic.RingSolver.html#11975" class="Bound">`lhs</a>
  <a id="12015" href="Tactic.RingSolver.html#12015" class="Bound">`rhsExpr</a> <a id="12024" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12026" href="Tactic.RingSolver.html#12278" class="Function">conv</a> <a id="12031" href="Tactic.RingSolver.html#11980" class="Bound">`rhs</a>
  <a id="12038" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="12045" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12047" href="Tactic.RingSolver.html#3299" class="Function">`trans</a> <a id="12054" href="Tactic.RingSolver.html#11951" class="Bound">`ring</a> <a id="12060" class="Symbol">(</a><a id="12061" href="Tactic.RingSolver.html#3231" class="Function">`sym</a> <a id="12066" href="Tactic.RingSolver.html#11951" class="Bound">`ring</a> <a id="12072" href="Tactic.RingSolver.html#11992" class="Bound">`lhsExpr</a><a id="12080" class="Symbol">)</a> <a id="12082" href="Tactic.RingSolver.html#12015" class="Bound">`rhsExpr</a>
  <a id="12093" class="Keyword">where</a>
  <a id="12101" href="Tactic.RingSolver.html#12101" class="Function">numVars</a> <a id="12109" class="Symbol">=</a> <a id="12111" href="Data.List.Base.html#4864" class="Function">List.length</a> <a id="12123" href="Tactic.RingSolver.html#11965" class="Bound">variables</a>

  <a id="12136" href="Tactic.RingSolver.html#12136" class="Function">varMap</a> <a id="12143" class="Symbol">:</a> <a id="12145" href="Tactic.RingSolver.html#1594" class="Function">VarMap</a>
  <a id="12154" href="Tactic.RingSolver.html#12136" class="Function">varMap</a> <a id="12161" href="Tactic.RingSolver.html#12161" class="Bound">i</a> <a id="12163" class="Symbol">=</a> <a id="12165" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="12175" class="Symbol">(λ</a> <a id="12178" href="Tactic.RingSolver.html#12178" class="Bound">x</a> <a id="12180" class="Symbol">→</a> <a id="12182" href="Tactic.RingSolver.html#4690" class="Function">`I</a> <a id="12185" href="Tactic.RingSolver.html#11951" class="Bound">`ring</a> <a id="12191" href="Tactic.RingSolver.html#12101" class="Function">numVars</a> <a id="12199" class="Symbol">(</a><a id="12200" href="Data.Nat.Reflection.html#711" class="Function">toFinTerm</a> <a id="12210" href="Tactic.RingSolver.html#12178" class="Bound">x</a><a id="12211" class="Symbol">))</a> <a id="12214" class="Symbol">(</a><a id="12215" href="Tactic.RingSolver.Core.NatSet.html#2881" class="Function">lookup</a> <a id="12222" href="Tactic.RingSolver.html#12161" class="Bound">i</a> <a id="12224" href="Tactic.RingSolver.html#11965" class="Bound">variables</a><a id="12233" class="Symbol">)</a>

  <a id="12238" href="Tactic.RingSolver.html#12238" class="Function">ρ</a> <a id="12240" class="Symbol">:</a> <a id="12242" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="12249" href="Tactic.RingSolver.html#12238" class="Function">ρ</a> <a id="12251" class="Symbol">=</a> <a id="12253" href="Tactic.RingSolver.html#2204" class="Function">curriedTerm</a> <a id="12265" href="Tactic.RingSolver.html#11965" class="Bound">variables</a>

  <a id="12278" href="Tactic.RingSolver.html#12278" class="Function">conv</a> <a id="12283" class="Symbol">=</a> <a id="12285" class="Symbol">λ</a> <a id="12287" href="Tactic.RingSolver.html#12287" class="Bound">t</a> <a id="12289" class="Symbol">→</a> <a id="12291" class="Keyword">do</a>
    <a id="12298" href="Tactic.RingSolver.html#12298" class="Bound">t&#39;</a> <a id="12301" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="12303" href="Tactic.RingSolver.html#5780" class="Function">convertTerm</a> <a id="12315" href="Tactic.RingSolver.html#11951" class="Bound">`ring</a> <a id="12321" href="Tactic.RingSolver.html#12101" class="Function">numVars</a> <a id="12329" href="Tactic.RingSolver.html#11957" class="Bound">opTerms</a> <a id="12337" href="Tactic.RingSolver.html#12136" class="Function">varMap</a> <a id="12344" href="Tactic.RingSolver.html#12287" class="Bound">t</a>
    <a id="12350" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a> <a id="12357" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12359" href="Tactic.RingSolver.html#4835" class="Function">`correct</a> <a id="12368" href="Tactic.RingSolver.html#11951" class="Bound">`ring</a> <a id="12374" href="Tactic.RingSolver.html#12101" class="Function">numVars</a> <a id="12382" href="Tactic.RingSolver.html#12298" class="Bound">t&#39;</a> <a id="12385" href="Tactic.RingSolver.html#12238" class="Function">ρ</a>

<a id="12388" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="12470" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="12545" class="Comment">-- intermediate step. Call it like so:</a>
<a id="12584" class="Comment">--</a>
<a id="12587" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12639" class="Comment">--   lemma₃ x y = begin</a>
<a id="12663" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12722" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12776" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12807" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12830" class="Comment">--</a>
<a id="12833" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12900" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12936" href="Tactic.RingSolver.html#12936" class="Function">solve-macro</a> <a id="12948" class="Symbol">:</a> <a id="12950" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12955" class="Symbol">→</a> <a id="12957" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="12962" class="Symbol">→</a> <a id="12964" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12969" class="Symbol">→</a> <a id="12971" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="12974" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="12976" href="Tactic.RingSolver.html#12936" class="Function">solve-macro</a> <a id="12988" href="Tactic.RingSolver.html#12988" class="Bound">variables</a> <a id="12998" href="Tactic.RingSolver.html#12998" class="Bound">ring</a> <a id="13003" href="Tactic.RingSolver.html#13003" class="Bound">hole</a> <a id="13008" class="Symbol">=</a> <a id="13010" class="Keyword">do</a>
  <a id="13015" href="Tactic.RingSolver.html#13015" class="Bound">`ring</a> <a id="13021" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13023" href="Tactic.RingSolver.html#2682" class="Function">checkIsRing</a> <a id="13035" class="Symbol">(</a><a id="13036" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="13040" href="Tactic.RingSolver.html#12998" class="Bound">ring</a> <a id="13045" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="13047" class="Symbol">)</a>
  <a id="13051" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="13062" href="Tactic.RingSolver.html#13062" class="Bound">operatorTerms</a> <a id="13076" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13078" href="Tactic.RingSolver.html#3583" class="Function">getRingOperatorTerms</a> <a id="13099" href="Tactic.RingSolver.html#13015" class="Bound">`ring</a>

  <a id="13108" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13155" href="Tactic.RingSolver.html#13155" class="Bound">listOfVariables′</a> <a id="13172" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13174" href="Tactic.RingSolver.html#11433" class="Function">checkIsListOfVariables</a> <a id="13197" href="Tactic.RingSolver.html#13015" class="Bound">`ring</a> <a id="13203" href="Tactic.RingSolver.html#12988" class="Bound">variables</a>
  <a id="13215" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="13226" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13231" href="Tactic.RingSolver.html#13231" class="Bound">variableIndices</a> <a id="13247" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13249" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="13254" class="Symbol">(</a><a id="13255" href="Tactic.RingSolver.html#11627" class="Function">getVariableIndices</a> <a id="13274" href="Tactic.RingSolver.html#13155" class="Bound">listOfVariables′</a><a id="13290" class="Symbol">)</a>
    <a id="13296" class="Keyword">where</a> <a id="13302" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13310" class="Symbol">→</a> <a id="13312" href="Tactic.RingSolver.html#10941" class="Function">malformedArgumentListError</a> <a id="13339" href="Tactic.RingSolver.html#13155" class="Bound">listOfVariables′</a>

  <a id="13359" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13397" href="Tactic.RingSolver.html#13397" class="Bound">hole′</a> <a id="13403" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13405" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="13415" href="Tactic.RingSolver.html#13003" class="Bound">hole</a> <a id="13420" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">&gt;&gt;=</a> <a id="13424" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="13433" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13438" class="Symbol">(</a><a id="13439" href="Tactic.RingSolver.html#13439" class="Bound">lhs</a> <a id="13443" href="Data.Vec.Base.html#1065" class="InductiveConstructor Operator">∷</a> <a id="13445" href="Tactic.RingSolver.html#13445" class="Bound">rhs</a> <a id="13449" href="Data.Vec.Base.html#1065" class="InductiveConstructor Operator">∷</a> <a id="13451" href="Data.Vec.Base.html#1046" class="InductiveConstructor">[]</a><a id="13453" class="Symbol">)</a> <a id="13455" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13457" href="Reflection.TypeChecking.Monad.Syntax.html#523" class="Function">pure</a> <a id="13462" class="Symbol">(</a><a id="13463" href="Tactic.RingSolver.html#1777" class="Function">getVisibleArgs</a> <a id="13478" class="Number">2</a> <a id="13480" href="Tactic.RingSolver.html#13397" class="Bound">hole′</a><a id="13485" class="Symbol">)</a>
    <a id="13491" class="Keyword">where</a> <a id="13497" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13505" class="Symbol">→</a> <a id="13507" href="Tactic.RingSolver.html#11199" class="Function">malformedGoalError</a> <a id="13526" href="Tactic.RingSolver.html#13397" class="Bound">hole′</a>

  <a id="13535" href="Tactic.RingSolver.html#13535" class="Bound">solution</a> <a id="13544" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="13546" href="Tactic.RingSolver.html#11855" class="Function">constructSolution</a> <a id="13564" href="Tactic.RingSolver.html#13015" class="Bound">`ring</a> <a id="13570" href="Tactic.RingSolver.html#13062" class="Bound">operatorTerms</a> <a id="13584" href="Tactic.RingSolver.html#13231" class="Bound">variableIndices</a> <a id="13600" href="Tactic.RingSolver.html#13439" class="Bound">lhs</a> <a id="13604" href="Tactic.RingSolver.html#13445" class="Bound">rhs</a>
  <a id="13610" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="13616" href="Tactic.RingSolver.html#13003" class="Bound">hole</a> <a id="13621" href="Tactic.RingSolver.html#13535" class="Bound">solution</a>

<a id="13631" class="Keyword">macro</a>
  <a id="solve"></a><a id="13639" href="Tactic.RingSolver.html#13639" class="Function">solve</a> <a id="13645" class="Symbol">:</a> <a id="13647" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13652" class="Symbol">→</a> <a id="13654" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="13659" class="Symbol">→</a> <a id="13661" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13666" class="Symbol">→</a> <a id="13668" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="13671" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="13675" href="Tactic.RingSolver.html#13639" class="Function">solve</a> <a id="13681" class="Symbol">=</a> <a id="13683" href="Tactic.RingSolver.html#12936" class="Function">solve-macro</a>
</pre></body></html>