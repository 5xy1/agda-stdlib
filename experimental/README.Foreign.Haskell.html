<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Foreign.Haskell</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A simple example of a program using the foreign function interface</a>
<a id="176" class="Comment">------------------------------------------------------------------------</a>

<a id="250" class="Keyword">module</a> <a id="257" href="README.Foreign.Haskell.html" class="Module">README.Foreign.Haskell</a> <a id="280" class="Keyword">where</a>

<a id="287" class="Comment">-- In order to be considered safe by Agda, the standard library cannot</a>
<a id="358" class="Comment">-- add COMPILE pragmas binding the inductive types it defines to concrete</a>
<a id="432" class="Comment">-- Haskell types.</a>

<a id="451" class="Comment">-- To work around this limitation, we have defined FFI-friendly versions</a>
<a id="524" class="Comment">-- of these types together with a zero-cost coercion `coerce`.</a>

<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Level.html" class="Module">Level</a> <a id="606" class="Keyword">using</a> <a id="612" class="Symbol">(</a><a id="613" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="618" class="Symbol">)</a>
<a id="620" class="Keyword">open</a> <a id="625" class="Keyword">import</a> <a id="632" href="Agda.Builtin.Int.html" class="Module">Agda.Builtin.Int</a>
<a id="649" class="Keyword">open</a> <a id="654" class="Keyword">import</a> <a id="661" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a>
<a id="678" class="Keyword">open</a> <a id="683" class="Keyword">import</a> <a id="690" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="705" class="Keyword">using</a> <a id="711" class="Symbol">(</a><a id="712" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="716" class="Symbol">;</a> <a id="718" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="731" class="Symbol">)</a>
<a id="733" class="Keyword">open</a> <a id="738" class="Keyword">import</a> <a id="745" href="Data.Char.html" class="Module">Data.Char</a> <a id="755" class="Symbol">as</a> <a id="758" class="Module">Char</a>
<a id="763" class="Keyword">open</a> <a id="768" class="Keyword">import</a> <a id="775" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="790" class="Symbol">as</a> <a id="793" class="Module">List</a> <a id="798" class="Keyword">using</a> <a id="804" class="Symbol">(</a><a id="805" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="809" class="Symbol">;</a> <a id="811" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="814" class="Symbol">;</a> <a id="816" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="818" class="Symbol">;</a> <a id="820" href="Data.List.Base.html#7358" class="Function">takeWhile</a><a id="829" class="Symbol">;</a> <a id="831" href="Data.List.Base.html#7537" class="Function">dropWhile</a><a id="840" class="Symbol">)</a>
<a id="842" class="Keyword">open</a> <a id="847" class="Keyword">import</a> <a id="854" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="870" class="Keyword">using</a> <a id="876" class="Symbol">(</a><a id="877" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="882" class="Symbol">;</a> <a id="884" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="888" class="Symbol">;</a> <a id="890" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="897" class="Symbol">)</a>
<a id="899" class="Keyword">open</a> <a id="904" class="Keyword">import</a> <a id="911" href="Data.Product.html" class="Module">Data.Product</a>
<a id="924" class="Keyword">open</a> <a id="929" class="Keyword">import</a> <a id="936" href="Function.html" class="Module">Function</a>
<a id="945" class="Keyword">open</a> <a id="950" class="Keyword">import</a> <a id="957" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="985" class="Keyword">import</a> <a id="992" href="Foreign.Haskell.html" class="Module">Foreign.Haskell</a> <a id="1008" class="Symbol">as</a> <a id="1011" class="Module">FFI</a>
<a id="1015" class="Keyword">open</a> <a id="1020" class="Keyword">import</a> <a id="1027" href="Foreign.Haskell.Coerce.html" class="Module">Foreign.Haskell.Coerce</a>

<a id="1051" class="Keyword">private</a>
  <a id="1061" class="Keyword">variable</a>
    <a id="1074" href="README.Foreign.Haskell.html#1074" class="Generalizable">a</a> <a id="1076" class="Symbol">:</a> <a id="1078" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1088" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a> <a id="1090" class="Symbol">:</a> <a id="1092" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1096" href="README.Foreign.Haskell.html#1074" class="Generalizable">a</a>

<a id="1099" class="Comment">-- Here we use the FFI version of Pair.</a>

<a id="1140" class="Keyword">postulate</a>
  <a id="primUncons"></a><a id="1152" href="README.Foreign.Haskell.html#1152" class="Postulate">primUncons</a>    <a id="1166" class="Symbol">:</a> <a id="1168" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1173" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a> <a id="1175" class="Symbol">→</a> <a id="1177" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1183" class="Symbol">(</a><a id="1184" href="Foreign.Haskell.Pair.html#520" class="Record">FFI.Pair</a> <a id="1193" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a> <a id="1195" class="Symbol">(</a><a id="1196" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1201" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a><a id="1202" class="Symbol">))</a>
  <a id="primCatMaybes"></a><a id="1207" href="README.Foreign.Haskell.html#1207" class="Postulate">primCatMaybes</a> <a id="1221" class="Symbol">:</a> <a id="1223" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1228" class="Symbol">(</a><a id="1229" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1235" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a><a id="1236" class="Symbol">)</a> <a id="1238" class="Symbol">→</a> <a id="1240" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1245" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a>
  <a id="primTestChar"></a><a id="1249" href="README.Foreign.Haskell.html#1249" class="Postulate">primTestChar</a>  <a id="1263" class="Symbol">:</a> <a id="1265" href="Agda.Builtin.Char.html#227" class="Postulate">Char</a> <a id="1270" class="Symbol">→</a> <a id="1272" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="primIntEq"></a><a id="1279" href="README.Foreign.Haskell.html#1279" class="Postulate">primIntEq</a>     <a id="1293" class="Symbol">:</a> <a id="1295" href="Agda.Builtin.Int.html#246" class="Datatype">Int</a> <a id="1299" class="Symbol">→</a> <a id="1301" href="Agda.Builtin.Int.html#246" class="Datatype">Int</a> <a id="1305" class="Symbol">→</a> <a id="1307" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>

<a id="1313" class="Symbol">{-#</a> <a id="1317" class="Keyword">COMPILE</a> <a id="1325" class="Keyword">GHC</a> <a id="1329" href="README.Foreign.Haskell.html#1152" class="Postulate">primUncons</a> <a id="1340" class="Pragma">=</a> <a id="1342" class="Pragma">\</a> <a id="1344" class="Pragma">_</a> <a id="1346" class="Pragma">_</a> <a id="1348" class="Pragma">xs</a> <a id="1351" class="Pragma">-&gt;</a> <a id="1354" class="Pragma">case</a> <a id="1359" class="Pragma">xs</a> <a id="1362" class="Pragma">of</a>
  <a id="1367" class="Pragma">{</a> <a id="1369" class="Pragma">[]</a>       <a id="1378" class="Pragma">-&gt;</a> <a id="1381" class="Pragma">Nothing</a>
  <a id="1391" class="Pragma">;</a> <a id="1393" class="Pragma">(x</a> <a id="1396" class="Pragma">:</a> <a id="1398" class="Pragma">xs)</a> <a id="1402" class="Pragma">-&gt;</a> <a id="1405" class="Pragma">Just</a> <a id="1410" class="Pragma">(x,</a> <a id="1414" class="Pragma">xs)</a>
  <a id="1420" class="Pragma">}</a>
<a id="1422" class="Symbol">#-}</a>

<a id="1427" class="Symbol">{-#</a> <a id="1431" class="Keyword">FOREIGN</a> <a id="1439" class="Pragma">GHC</a> <a id="1443" class="Pragma">import</a> <a id="1450" class="Pragma">Data.Maybe</a> <a id="1461" class="Symbol">#-}</a>
<a id="1465" class="Symbol">{-#</a> <a id="1469" class="Keyword">COMPILE</a> <a id="1477" class="Keyword">GHC</a> <a id="1481" href="README.Foreign.Haskell.html#1207" class="Postulate">primCatMaybes</a> <a id="1495" class="Pragma">=</a> <a id="1497" class="Pragma">\</a> <a id="1499" class="Pragma">_</a> <a id="1501" class="Pragma">_</a> <a id="1503" class="Pragma">-&gt;</a> <a id="1506" class="Pragma">catMaybes</a> <a id="1516" class="Symbol">#-}</a>

<a id="1521" class="Symbol">{-#</a> <a id="1525" class="Keyword">COMPILE</a> <a id="1533" class="Keyword">GHC</a> <a id="1537" href="README.Foreign.Haskell.html#1249" class="Postulate">primTestChar</a> <a id="1550" class="Pragma">=</a> <a id="1552" class="Pragma">(&#39;-&#39;</a> <a id="1557" class="Pragma">/=)</a> <a id="1561" class="Symbol">#-}</a>

<a id="1566" class="Symbol">{-#</a> <a id="1570" class="Keyword">COMPILE</a> <a id="1578" class="Keyword">GHC</a> <a id="1582" href="README.Foreign.Haskell.html#1279" class="Postulate">primIntEq</a> <a id="1592" class="Pragma">=</a> <a id="1594" class="Pragma">(==)</a> <a id="1599" class="Symbol">#-}</a>

<a id="1604" class="Comment">-- We however want to use the notion of Pair internal to the standard library.</a>
<a id="1683" class="Comment">-- For this we use `coerce` to take use back to the types we are used to.</a>

<a id="1758" class="Comment">-- The typeclass mechanism uses the coercion rules for Pair, as well as the</a>
<a id="1834" class="Comment">-- knowledge that natural numbers are represented as integers.</a>
<a id="1897" class="Comment">-- We additionally benefit from the congruence rules for List, Maybe, Char,</a>
<a id="1973" class="Comment">-- Bool, and a reflexivity principle for variable A.</a>

<a id="uncons"></a><a id="2027" href="README.Foreign.Haskell.html#2027" class="Function">uncons</a> <a id="2034" class="Symbol">:</a> <a id="2036" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2041" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a> <a id="2043" class="Symbol">→</a> <a id="2045" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2051" class="Symbol">(</a><a id="2052" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a> <a id="2054" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2056" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2061" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a><a id="2062" class="Symbol">)</a>
<a id="2064" href="README.Foreign.Haskell.html#2027" class="Function">uncons</a> <a id="2071" class="Symbol">=</a> <a id="2073" href="Foreign.Haskell.Coerce.html#2592" class="Postulate">coerce</a> <a id="2080" href="README.Foreign.Haskell.html#1152" class="Postulate">primUncons</a>

<a id="catMaybes"></a><a id="2092" href="README.Foreign.Haskell.html#2092" class="Function">catMaybes</a> <a id="2102" class="Symbol">:</a> <a id="2104" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2109" class="Symbol">(</a><a id="2110" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2116" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a><a id="2117" class="Symbol">)</a> <a id="2119" class="Symbol">→</a> <a id="2121" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2126" href="README.Foreign.Haskell.html#1088" class="Generalizable">A</a>
<a id="2128" href="README.Foreign.Haskell.html#2092" class="Function">catMaybes</a> <a id="2138" class="Symbol">=</a> <a id="2140" href="README.Foreign.Haskell.html#1207" class="Postulate">primCatMaybes</a>

<a id="testChar"></a><a id="2155" href="README.Foreign.Haskell.html#2155" class="Function">testChar</a> <a id="2164" class="Symbol">:</a> <a id="2166" href="Agda.Builtin.Char.html#227" class="Postulate">Char</a> <a id="2171" class="Symbol">→</a> <a id="2173" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="2178" href="README.Foreign.Haskell.html#2155" class="Function">testChar</a> <a id="2187" class="Symbol">=</a> <a id="2189" href="Foreign.Haskell.Coerce.html#2592" class="Postulate">coerce</a> <a id="2196" href="README.Foreign.Haskell.html#1249" class="Postulate">primTestChar</a>
  <a id="2211" class="Comment">-- note that coerce is useless here but the proof could come from</a>
  <a id="2279" class="Comment">-- either `coerce-fun coerce-refl coerce-refl` or `coerce-refl` alone</a>
  <a id="2351" class="Comment">-- We (and Agda) do not care which proof we got.</a>

<a id="eqNat"></a><a id="2401" href="README.Foreign.Haskell.html#2401" class="Function">eqNat</a> <a id="2407" class="Symbol">:</a> <a id="2409" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="2413" class="Symbol">→</a> <a id="2415" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="2419" class="Symbol">→</a> <a id="2421" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="2426" href="README.Foreign.Haskell.html#2401" class="Function">eqNat</a> <a id="2432" class="Symbol">=</a> <a id="2434" href="Foreign.Haskell.Coerce.html#2592" class="Postulate">coerce</a> <a id="2441" href="README.Foreign.Haskell.html#1279" class="Postulate">primIntEq</a>
  <a id="2453" class="Comment">-- We can coerce `Nat` to `Int` but not `Int` to `Nat`. This fundamentally</a>
  <a id="2530" class="Comment">-- relies on the fact that `Coercible` understands that functions are</a>
  <a id="2602" class="Comment">-- contravariant.</a>

<a id="2621" class="Keyword">open</a> <a id="2626" class="Keyword">import</a> <a id="2633" href="IO.html" class="Module">IO</a>
<a id="2636" class="Keyword">open</a> <a id="2641" class="Keyword">import</a> <a id="2648" href="Codata.Musical.Notation.html" class="Module">Codata.Musical.Notation</a>
<a id="2672" class="Keyword">open</a> <a id="2677" class="Keyword">import</a> <a id="2684" href="Data.String.Base.html" class="Module">Data.String.Base</a>
<a id="2701" class="Keyword">open</a> <a id="2706" class="Keyword">import</a> <a id="2713" href="Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a>

<a id="2740" class="Comment">-- example program using uncons, catMaybes, and testChar</a>

<a id="main"></a><a id="2798" href="README.Foreign.Haskell.html#2798" class="Function">main</a> <a id="2803" class="Symbol">=</a> <a id="2805" href="IO.html#1209" class="Function">run</a> <a id="2809" href="Function.Base.html#1919" class="Function Operator">$</a>
  <a id="2813" href="Agda.Builtin.Coinduction.html#221" class="CoinductiveConstructor Operator">♯</a> <a id="2815" href="IO.html#3046" class="Function">readFiniteFile</a> <a id="2830" class="String">&quot;README/Foreign/Haskell.agda&quot;</a> <a id="2860" class="Comment">{- read this file -}</a> <a id="2881" href="IO.html#1053" class="InductiveConstructor Operator">&gt;&gt;=</a> <a id="2885" class="Symbol">λ</a> <a id="2887" href="README.Foreign.Haskell.html#2887" class="Bound">f</a> <a id="2889" class="Symbol">→</a>
  <a id="2893" href="Agda.Builtin.Coinduction.html#221" class="CoinductiveConstructor Operator">♯</a> <a id="2895" class="Keyword">let</a> <a id="2899" href="README.Foreign.Haskell.html#2899" class="Bound">chars</a>   <a id="2907" class="Symbol">=</a> <a id="2909" href="Data.String.Base.html#1513" class="Primitive">toList</a> <a id="2916" href="README.Foreign.Haskell.html#2887" class="Bound">f</a> <a id="2918" class="Keyword">in</a>
    <a id="2925" class="Keyword">let</a> <a id="2929" href="README.Foreign.Haskell.html#2929" class="Bound">cleanup</a> <a id="2937" class="Symbol">=</a> <a id="2939" href="README.Foreign.Haskell.html#2092" class="Function">catMaybes</a> <a id="2949" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2951" href="Data.List.Base.html#1497" class="Function">List.map</a> <a id="2960" class="Symbol">(λ</a> <a id="2963" href="README.Foreign.Haskell.html#2963" class="Bound">c</a> <a id="2965" class="Symbol">→</a> <a id="2967" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="2970" href="README.Foreign.Haskell.html#2155" class="Function">testChar</a> <a id="2979" href="README.Foreign.Haskell.html#2963" class="Bound">c</a> <a id="2981" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="2986" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2991" href="README.Foreign.Haskell.html#2963" class="Bound">c</a> <a id="2993" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="2998" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="3005" class="Symbol">)</a> <a id="3007" class="Keyword">in</a>
    <a id="3014" class="Keyword">let</a> <a id="3018" href="README.Foreign.Haskell.html#3018" class="Bound">cleaned</a> <a id="3026" class="Symbol">=</a> <a id="3028" href="Data.List.Base.html#7537" class="Function">dropWhile</a> <a id="3038" class="Symbol">(</a><a id="3039" class="String">&#39;\n&#39;</a> <a id="3044" href="Data.Char.Properties.html#1963" class="Function Operator">≟_</a><a id="3046" class="Symbol">)</a> <a id="3048" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3050" href="README.Foreign.Haskell.html#2929" class="Bound">cleanup</a> <a id="3058" href="README.Foreign.Haskell.html#2899" class="Bound">chars</a> <a id="3064" class="Keyword">in</a>
  <a id="3069" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="3074" href="README.Foreign.Haskell.html#2027" class="Function">uncons</a> <a id="3081" href="README.Foreign.Haskell.html#3018" class="Bound">cleaned</a> <a id="3089" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="3092" class="Symbol">λ</a> <a id="3094" class="Keyword">where</a>
    <a id="3104" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>         <a id="3120" class="Symbol">→</a> <a id="3122" href="IO.html#3725" class="Function">putStrLn</a> <a id="3131" class="String">&quot;I cannot believe this file is filed with dashes only!&quot;</a>
    <a id="3191" class="Symbol">(</a><a id="3192" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3197" class="Symbol">(</a><a id="3198" href="README.Foreign.Haskell.html#3198" class="Bound">c</a> <a id="3200" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3202" href="README.Foreign.Haskell.html#3202" class="Bound">cs</a><a id="3204" class="Symbol">))</a> <a id="3207" class="Symbol">→</a> <a id="3209" href="IO.html#3725" class="Function">putStrLn</a> <a id="3218" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3220" href="Data.String.Base.html#2550" class="Function">unlines</a>
                    <a id="3248" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3250" class="Symbol">(</a><a id="3251" class="String">&quot;First (non dash) character: &quot;</a> <a id="3282" href="Data.String.Base.html#2177" class="Function Operator">++</a> <a id="3285" href="Data.Char.Base.html#1112" class="Primitive">Char.show</a> <a id="3295" href="README.Foreign.Haskell.html#3198" class="Bound">c</a><a id="3296" class="Symbol">)</a>
                    <a id="3318" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3320" class="Symbol">(</a><a id="3321" class="String">&quot;Rest (dash free) of the line: &quot;</a> <a id="3354" href="Data.String.Base.html#2177" class="Function Operator">++</a> <a id="3357" href="Data.String.Base.html#1546" class="Primitive">fromList</a> <a id="3366" class="Symbol">(</a><a id="3367" href="Data.List.Base.html#7358" class="Function">takeWhile</a> <a id="3377" class="Symbol">(</a><a id="3378" href="Relation.Nullary.Negation.html#1286" class="Function">¬?</a> <a id="3381" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="3383" class="Symbol">(</a><a id="3384" class="String">&#39;\n&#39;</a> <a id="3389" href="Data.Char.Properties.html#1963" class="Function Operator">≟_</a><a id="3391" class="Symbol">))</a> <a id="3394" href="README.Foreign.Haskell.html#3202" class="Bound">cs</a><a id="3396" class="Symbol">))</a>
                    <a id="3419" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3421" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>

<a id="3425" class="Comment">-- You can compile and run this test by writing:</a>
<a id="3474" class="Comment">-- agda -c Haskell.agda</a>
<a id="3498" class="Comment">-- ../../Haskell</a>

<a id="3516" class="Comment">-- You should see the following text (without the indentation on the left):</a>
<a id="3592" class="Comment">--   First (non dash) character: &#39; &#39;</a>
<a id="3629" class="Comment">--   Rest (dash free) of the line: The Agda standard library</a>
</pre></body></html>